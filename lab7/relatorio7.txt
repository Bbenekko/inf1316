Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Execute o programa Corrida de Sapo algumas vezes e
analise os resultados sobre a ordem de chegada dos sapos. 
Obs: compile com a opção –lpthread

-----------------------------------------------------
ARQUIVO corrida_dos_sapos.c

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#define NUM_THREADS 5
#define PULO_MAXIMO 100
#define DESCANSO_MAXIMO 1
#define DISTANCIA_PARA_CORRER 100
static int classificacao = 1;
static pthread_mutex_t lock;
static char * resp[200];
static int cont = 0;

void *Correr(void *sapo)
{
    int pulos = 0;
    int distanciaJaCorrida = 0;
    while (distanciaJaCorrida <= DISTANCIA_PARA_CORRER) 
    {
        int pulo = rand() % PULO_MAXIMO;
        distanciaJaCorrida += pulo;
        pulos++;
        printf("Sapo %d pulou\n", (int) sapo);
        int descanso = rand() % DESCANSO_MAXIMO;
        sleep(descanso);
    }
    printf("Sapo %d chegou na posicaoo %d com %d pulos\n", (int) sapo, classificacao, pulos);
    cont++;
    classificacao++;
    pthread_exit(NULL);
}

int main()
{
    classificacao =1;
    pthread_t threads[NUM_THREADS];
    int t;
    printf("Corrida iniciada ... \n");
    for(t=0;t < NUM_THREADS;t++) pthread_create(&threads[t], NULL, Correr, (void *) t);
    for(t=0;t < NUM_THREADS; t++) pthread_join(threads[t],NULL);
    printf("\n Acabou!!\n");
    pthread_exit(NULL);
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o corrida corrida_dos_sapos.c -lpthread
$./corrida
-----------------------------------------------------
RESULTADO 1

Corrida iniciada ... 
Sapo 1 pulou
Sapo 2 pulou
Sapo 0 pulou
Sapo 3 pulou
Sapo 2 pulou
Sapo 4 pulou
Sapo 0 pulou
Sapo 1 pulou
Sapo 3 pulou
Sapo 2 chegou na posicaoo 1 com 2 pulos
Sapo 4 pulou
Sapo 1 chegou na posicaoo 2 com 2 pulos
Sapo 3 chegou na posicaoo 3 com 2 pulos
Sapo 0 chegou na posicaoo 2 com 2 pulos
Sapo 4 chegou na posicaoo 5 com 2 pulos

Acabou!!

RESULTADO 2

Corrida iniciada ... 
Sapo 0 pulou
Sapo 2 pulou
Sapo 1 pulou
Sapo 0 pulou
Sapo 3 pulou
Sapo 2 pulou
Sapo 4 pulou
Sapo 4 pulou
Sapo 1 pulou
Sapo 0 chegou na posicaoo 1 com 2 pulos
Sapo 3 pulou
Sapo 2 chegou na posicaoo 2 com 2 pulos
Sapo 1 pulou
Sapo 3 chegou na posicaoo 3 com 2 pulos
Sapo 4 pulou
Sapo 1 pulou
Sapo 4 chegou na posicaoo 4 com 3 pulos
Sapo 1 chegou na posicaoo 5 com 4 pulos

Acabou!!

-----------------------------------------------------
CONCLUSÃO

Após compilar o programa com a opção -lpthread que diz ao linker que é para incluir 
a biblioteca de Threads e rodar o executável, é perceptível que a ordem em que os 
sapos chegam são diferentes a cada vez que o executável é executado. Isso mostra bem 
a concorrência entre as threads em que não há uma ordem correta de quando cada uma é
executada. Além disso, também é perceptível uma das características de threads: o 
compartilhamento das variáveis de modo que onde houve mudança, no caso do acréscimo da
variável em que o acréscimo em uma thread era percebida pela outra o que não acontece 
entre criação de processos filhos. É importante comentar que no resultado 1 houve um 
falso empate. Parece que 2 sapos chegaram ao mesmo tempo, mas na verdade, isso ocorre pois 
quando o primeiro printa, entre o tempo do final do print e dele incrementar o contador a 
thread que representa o outro sapo printa também e o modifico, o que representa um falso empate.  

-----------------------------------------------------

Questão 2) 
Usando mutex, modifique o programa Corrida de Sampo
para que o problema identificado anteriormente não ocorra.
-----------------------------------------------------
ARQUIVO corrida_com_mutex.c

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#define NUM_THREADS 5
#define PULO_MAXIMO 100
#define DESCANSO_MAXIMO 1
#define DISTANCIA_PARA_CORRER 100
static int classificacao = 1;
static pthread_mutex_t lock;
static char * resp[200];
static int cont = 0;

void *Correr(void *sapo)
{
    int pulos = 0;
    int distanciaJaCorrida = 0;
    while (distanciaJaCorrida <= DISTANCIA_PARA_CORRER) 
    {
        int pulo = rand() % PULO_MAXIMO;
        distanciaJaCorrida += pulo;
        pulos++;
        printf("Sapo %d pulou\n", (int) sapo);
        int descanso = rand() % DESCANSO_MAXIMO;
        sleep(descanso);
    }
    pthread_mutex_lock( &lock); 
    printf("Sapo %d chegou na posicaoo %d com %d pulos\n", (int) sapo, classificacao, pulos);
    cont++;
    pthread_mutex_unlock( &lock );
    classificacao++;
    pthread_exit(NULL);
}

int main()
{
    classificacao =1;
    pthread_t threads[NUM_THREADS];
    int t;
    printf("Corrida iniciada ... \n");
    for(t=0;t < NUM_THREADS;t++) pthread_create(&threads[t], NULL, Correr, (void *) t);
    for(t=0;t < NUM_THREADS; t++) pthread_join(threads[t],NULL);
    printf("\n Acabou!!\n");
    pthread_exit(NULL);

}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o corrida corrida_com_mutex.c -lpthread
$./corrida 

-----------------------------------------------------
RESULTADO 1

Corrida iniciada ... 
Sapo 0 pulou
Sapo 1 pulou
Sapo 2 pulou
Sapo 1 pulou
Sapo 2 pulou
Sapo 0 pulou
Sapo 4 pulou
Sapo 1 chegou na posicaoo 1 com 2 pulos
Sapo 3 pulou
Sapo 2 chegou na posicaoo 2 com 2 pulos
Sapo 4 pulou
Sapo 3 pulou
Sapo 0 chegou na posicaoo 3 com 2 pulos
Sapo 4 chegou na posicaoo 4 com 2 pulos
Sapo 3 chegou na posicaoo 5 com 2 pulos

RESULTADO 2

Corrida iniciada ... 
Sapo 0 pulou
Sapo 2 pulou
Sapo 1 pulou
Sapo 0 pulou
Sapo 4 pulou
Sapo 3 pulou
Sapo 2 pulou
Sapo 4 pulou
Sapo 1 pulou
Sapo 0 chegou na posicaoo 1 com 2 pulos
Sapo 3 pulou
Sapo 2 chegou na posicaoo 2 com 2 pulos
Sapo 4 chegou na posicaoo 3 com 2 pulos
Sapo 1 pulou
Sapo 3 chegou na posicaoo 4 com 2 pulos
Sapo 1 pulou
Sapo 1 chegou na posicaoo 5 com 4 pulos

-----------------------------------------------------

CONCLUSÃO

Para evitar empates falsos, foi utilizado um mutex em que a variável contadora
foi a lock. Foram chamadas as funções que garantem a exclusão mútua pthread_mutex_lock()
e pthread_mutex_unlock() respectivamente acima e abaixo das seguintes linhas de código:

printf("Sapo %d chegou na posicaoo %d com %d pulos\n", (int) sapo, classificacao, pulos);
cont++;

Foram escolhidas essas linhas para serem englobada pela exclusão múltipla pois, assim que uma 
thread entra na execução dessas linhas, as outras pausam. Então a que está executando consegue, 
sem problemas, fazer o print e incrementar o cont de modo que a próxima que entrar nessa parte 
já estará com a contagem certinha, não pode atropelar esse processo.

-----------------------------------------------------

Questão 3) Usando threads, escreva um programa C que implemente o
problema do produtor/consumidor. O produtor deve produzir
dados (números inteiros pseudo-aleatórios) a cada 1 segundo
colocando-os em uma fila (buffer, implementação circular). O
consumidor deve retirar dados da fila a cada 2 segundos. O
tamanho máximo da fila deve ser de 8 elementos (MAXFILA) e
tanto o produtor como o consumidor devem produzir/consumir
64 elementos (números inteiros de 1 a 64, por exemplo)
evitando condições de corrida. Variáveis compartilhadas entre
threads são simplesmente variáveis globais.
-----------------------------------------------------
ARQUIVO ex3.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>

#define MAX_PRODUZ 64
#define MAXFILA 8
// cores para output
#define RED  "\x1b[31m"
#define YELLOW  "\x1b[33m"
#define BLUE  "\x1b[34m"
#define RESET   "\x1b[0m"

pthread_mutex_t mutex; // mutex semaphore 
pthread_cond_t consumer_c, producer_c; // 2 condition variables for consumer, and producer

int fila[MAXFILA]; // fila de 8 posições
int vaziosFila = MAXFILA;

void* producer(void *ptr)
{
    for (int i = 1; i <= MAX_PRODUZ; i++) {
        sleep(1);
        pthread_mutex_lock(&mutex); // entrando zona critica
        while(vaziosFila == 0) // espera caso a fila esteja cheia
        {
            printf(RED"Fila cheia!\n"RESET);
            pthread_cond_wait(&producer_c, &mutex);
        }

        fila[MAXFILA-vaziosFila] = rand() + 1;
        printf(BLUE"Conteudo inserido na fila: %d\n"RESET, fila[MAXFILA-vaziosFila]);
        vaziosFila--;

        pthread_cond_signal(&consumer_c); /* wake up consumer */
        pthread_mutex_unlock(&mutex); /* release the buffer */
    }
    pthread_exit(0);
}

void* consumer(void *ptr) 
{
    for (int i = 1; i <= MAX_PRODUZ; i++) 
    {
        sleep(2);
        pthread_mutex_lock(&mutex); // entrando na zona critica
        while (vaziosFila == MAXFILA) // espera caso a fila esteja vazia
        {
            printf(RED"Fila vazia!\n"RESET);
            pthread_cond_wait(&consumer_c, &mutex);
        }

        printf(YELLOW"Conteudo lido da primeira posição da fila: %d\n"RESET, fila[0]);
        fila[0] = 0; /* consume the item */
        vaziosFila++;

        for(int j = 0; j < (MAXFILA - 1); j++) fila[j] = fila[j+1];

        pthread_cond_signal(&producer_c); /* wake up producer*/
        pthread_mutex_unlock(&mutex); /* release the buffer */
    }
    pthread_exit(0);
}

int main() 
{
    pthread_t pro, con;

    // Initialize the mutex and condition variables
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&consumer_c, NULL); /* Initialize consumer cond variable */
    pthread_cond_init(&producer_c, NULL); /* Initialize producer cond variable */

    // Create the threads
    pthread_create(&con, NULL, consumer, NULL);
    pthread_create(&pro, NULL, producer, NULL);

    pthread_join(con, NULL);
    pthread_join(pro, NULL);
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex3 ex3.c
$./ex3
-----------------------------------------------------

RESULTADO

Está dentro do arquivo "output_da_3.txt", pois foi muito grande, já que foram 64 elementos
processados/criados.
-----------------------------------------------------

CONCLUSÃO 

A base desse programa foi o código dado na aula "Capítulo 2 - Gerenciamento de Processos, Threads e Escalonamento".
Apenas foram feitas alterações para suportar uma fila ao invés de um buffer único (que era o
exemplo dado na aula). As saídas foram coloridas para facilitar a leitura:
- AZUL: entrada
- AMARELO: saída
- VERMELHO: warning
As alterações para a fila foram checagem se a fila está cheia (através de um variável global
que conta os espaços vazios).

-----------------------------------------------------

Questão 4) Modifique o programa anterior, para que haja 2 (ou mais)
threads consumidor e 2 (ou mais) threads produtor. O que muda
em relação ao uso do mutex e da variável de condição?

-----------------------------------------------------
ARQUIVO ex4.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>

#define MAX_PRODUZ 64
#define MAXFILA 8
#define NUM_THREADS 2 // possui 2 threads

// cores para output
#define RED  "\x1b[31m"
#define YELLOW  "\x1b[33m"
#define BLUE  "\x1b[34m"
#define RESET   "\x1b[0m"

pthread_mutex_t mutex; // mutex semaphore 
pthread_cond_t consumer_c, producer_c; // 2 condition variables for consumer, and producer

int fila[MAXFILA]; // fila de 8 posições
int vaziosFila = MAXFILA;

void* producer(void *ptr)
{
    for (int i = 1; i <= (MAX_PRODUZ/NUM_THREADS); i++) {
        sleep(1);
        pthread_mutex_lock(&mutex); // entrando zona critica
        while(vaziosFila == 0) // espera caso a fila esteja cheia
        {
            printf(RED"Fila cheia!\n"RESET);
            pthread_cond_wait(&producer_c, &mutex);
        }

        fila[MAXFILA-vaziosFila] = rand() + 1;
        printf(BLUE"Conteudo inserido na fila: %d\n"RESET, fila[MAXFILA-vaziosFila]);
        vaziosFila--;

        pthread_cond_signal(&consumer_c); /* wake up consumer */
        pthread_mutex_unlock(&mutex); /* release the buffer */
    }
    pthread_exit(0);
}

void* consumer(void *ptr) 
{
    for (int i = 1; i <= (MAX_PRODUZ/NUM_THREADS); i++) 
    {
        sleep(2);
        pthread_mutex_lock(&mutex); // entrando na zona critica
        while (vaziosFila == MAXFILA) // espera caso a fila esteja vazia
        {
            printf(RED"Fila vazia!\n"RESET);
            pthread_cond_wait(&consumer_c, &mutex);
        }

        printf(YELLOW"Conteudo lido da primeira posição da fila: %d\n"RESET, fila[0]);
        fila[0] = 0; /* consume the item */
        vaziosFila++;

        for(int j = 0; j < (MAXFILA - 1); j++) fila[j] = fila[j+1];

        pthread_cond_signal(&producer_c); /* wake up producer*/
        pthread_mutex_unlock(&mutex); /* release the buffer */
    }
    pthread_exit(0);
}

int main() 
{
    pthread_t pro, con, pro2, con2;

    // Initialize the mutex and condition variables
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&consumer_c, NULL); /* Initialize consumer cond variable */
    pthread_cond_init(&producer_c, NULL); /* Initialize producer cond variable */

    // Create the threads
    pthread_create(&con, NULL, consumer, NULL);
    pthread_create(&pro, NULL, producer, NULL);
    pthread_create(&con2, NULL, consumer, NULL);
    pthread_create(&pro2, NULL, producer, NULL);

    pthread_join(con, NULL);
    pthread_join(pro, NULL);
    pthread_join(con2, NULL);
    pthread_join(pro2, NULL);
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex4 ex4.c
$./ex4

-----------------------------------------------------
RESULTADO

Está dentro do arquivo "output_da_4.txt", pois foi muito grande, já que foram 64 elementos
processados/criados.

-----------------------------------------------------
CONCLUSÃO

O código se assemelha muito ao código anterior (questão 3), com apenas a diferença
de que a condição de loop para geração do total de elementos foi dividida sobre a 
quantidade de threads (ex: no caso de 2 threads, cada uma trabalhará apenas com uma 
metade  (1/2) do total).
O mutex não teve nenhuma mudança no código.
Vale ressaltar que esse programa foi muito mais rápido que o anterior, devido
a maior quantidade de threads trabalhando.