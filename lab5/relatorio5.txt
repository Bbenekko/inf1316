Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Execute o programa “ctrl-c.c”.
Digite Ctrl-C e Ctrl-\. Analise o resultado.

Neste mesmo programa, remova os
comandos signal( ) e repita o teste anterior
observando os resultados.
-----------------------------------------------------
ARQUIVO ex1.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

#define EVER ;;
void intHandler(int sinal);
void quitHandler(int sinal);

int main (void)
{
void (*p)(int); // ponteiro para função que recebe int como
    // parâmetro
    p = signal(SIGINT, intHandler);
    printf("Endereco do manipulador anterior %p\n", p);
    p = signal(SIGQUIT, quitHandler);
    printf("Endereco do manipulador anterior %p\n", p);
    puts ("Ctrl-C desabilitado. Use Ctrl-\\ para terminar");
    for(EVER);
}
void intHandler(int sinal)
{
    printf("Você pressionou Ctrl-C (%d) \n", sinal);
}
void quitHandler(int sinal)
{
    printf("Terminando o processo...\n");
    exit (0);
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ctrl-c ctrl-c.c
$./ctrl-c
-----------------------------------------------------
RESULTADO 1

Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^CVocê pressionou Ctrl-C (2) 
^CVocê pressionou Ctrl-C (2) 
^CVocê pressionou Ctrl-C (2) 
^\Terminando o processo...

RESULTADO 2

Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^C

-----------------------------------------------------
CONCLUSÃO

No programa original, a função signal foi utilizada duas vezes, de modo que na primeira vez ela captura
o sinal SIGINT que é recebido quando se escrever ctrl-c na shell enquanto roda um programa para interrompê-lo 
e na segunda vez ele captura o sinal SIGQUIT que também interrompre o programa, mas ele gera um core dump. 
Na captura do ctrl-c, ele passa a chamar a função intHandler que printa uma mensagem e na com ctrl-\, ela
printa uma mensagem e dá um exit no programa. Com isso, ao tratar o sinal de ctrl-c, ele já não afeta mais o 
programa, ou seja, ao usar ctrl-c no terminal, o programa já não é mais terminado, mas printa a mensagem da
função intHandler já que ela foi cadastrada como a reação, o que deve ser feito quando esse sinal é recebido. 
Ao usar ctrl-\, o programa é terminado, mas não da forma que normalmente aconteceria: a função quitHandler é 
acionada, o que faz com que, ao terminar o programa com um exit(0), não há criação de um core dump.

Quando se remove os comandos signal(), tanto o ctrl-c, quanto o ctrl-\ encerram o programa do jeito padrão: o 
ctrl-c interrompendo e o ctrl-\ criando o core dump.

-----------------------------------------------------

Questão 2) Faça um programa para redirecionar a entrada e
a saída, lendo os dados de um arquivo e gerando
a saída em outro.
-----------------------------------------------------
ARQUIVO ex2.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main ()
{
    int fdIn, fdOut;
    int retorno; /* valor de retorno de dup */
    int retorno2; 

    if ((fdIn=open("arquivoEnt.txt", O_RDONLY,0666)) == -1)
    {
        perror("Error open()");
        return -1;
    }
    close(0);
    dup(fdIn);

    if ((fdOut=open("arquivoSaida.txt", O_RDWR|O_CREAT|O_TRUNC,0666)) == -1)
    {
        perror("Error open()");
        return -1;
    }
    close(1);
    dup(fdOut);

    char conteudo[1000];
    fgets(conteudo, sizeof conteudo, stdin);
    printf("Conteudo do arquivoEnt: %s", conteudo);
    
    return 0;
}

----------------------------------------------------
ARQUIVO arquivoEnt.txt
Mensagem muito legal!

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex2 ex2.c
$./ex2 &

-----------------------------------------------------
RESULTADO

(Dentro de arquivoSaida.txt):
Conteudo do arquivoEnt: Mensagem muito legal!

-----------------------------------------------------

CONCLUSÃO

No código foram fechadas a entrada e saída padrão, e foram abertas no lugar a fdIn e fdOut, 
que direcionam a entrada padrão para o arquivoEnt.txt e a saída padrão arquivoSaida.txt.
Logo com fgets é possível ler o arquivoEnt e com printf é possível escrever no arquivoSaida.

-----------------------------------------------------

Questão 3) Busca paralela em vetor
Faça um programa paralelo (com pelo menos 4 processos) para localizar 
uma chave em um vetor.

Crie uma memória compartilhada com dados numéricos inteiros e desordenados e a divida
pelo número de processos;

Cada processo deve procurar o dado na sua área de memória e informar a posição onde o
dado foi localizado. 
-----------------------------------------------------
ARQUIVO filhocidio.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>

void childhandler(int signo);
int delay;
int main (int argc, char *argv[])
{
    pid_t pid;
    signal(SIGCHLD, childhandler);
    if ((pid = fork()) < 0)
    {
        fprintf(stderr, "Erro ao criar filho\n");
        exit(-1);
    }
    if (pid == 0) /* child */
        execve(argv[2], 0, 0); /* ou sleep(3);*/
    else /* parent */
    {
        sscanf(argv[1], "%d", &delay); /* read delay from command line */
        sleep(delay);
        printf("Program %s exceeded limit of %d seconds!\n", argv[2], delay);
        kill(pid, SIGKILL);
        sleep(1); /* necessary for SIGCHLD to arrive */
    }
    return 0;
}

void childhandler(int signo) /* Executed if child dies before parent */
{
    int status;
    pid_t pid = wait(&status);
    printf("Child %d terminated within %d seconds com estado %d.\n", pid, delay, status);
    exit(0);
}


ARQUIVO sleep5.c

#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    printf(stdout, "Acordei!\n");
    return 0;
}


ARQUIVO sleep15.c

#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    printf(stdout, "Acordei!\n");
    return 0;
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o sleep5 sleep5.c
$gcc -Wall -o sleep15 sleep15.c
$gcc -Wall -o filhocidio filhocidio.c
$./filhocidio 10 ./sleep5
$./filhocidio 10 ./sleep15
-----------------------------------------------------

RESULTADO

indo dormir...
Acordei!
Child 8296 terminated within 10 seconds com estado 0.

----

indo dormir...
Program ./sleep15 exceeded limit of 10 seconds!
Child 8360 terminated within 10 seconds com estado 9.
-----------------------------------------------------

CONCLUSÃO 

Tanto os programas sleep5 e sleep 15 funcionam de forma semelhante: Assim que começam a rodar, 
printam uma mensagem, são pausados por uma determinada quantidade de segundos e printam mais  uma mensagem. 

O filhocidio inicia utilizando a função signal que cadastra uma reação ao recebimento do sinal do tipo SIGCHLD
que é emitido quando há a pausa, continuidade ou a morte de um filho antes do pai. A reação criada foi a função
childhandler que é chamada quando há o recebimento desse sinal. Nela, o pai recebe o status do processo pelo wait
e printa as informações do processo fiho. 

Voltando ao código, é criado um filho no fork. Foram usados 2 programas filhos: sleep5 e sleep 15 em que cada um
printa uma mensagem, "dorme" por 5 e 15 segundos respectivamente e depois printam outra mensagem.  

Enquanto o filho roda, o pai "dorme" por uma quantidade de segundos determinada por um parâmetro passado pela linha
de comando. Se o programa filho, que até então estava rodando em paralelo, não morrer antes que a "soneca" do pai
termine, ele printa a quantidade de tempo até então e mata o filho com o comando kill, e depois "dorme" novamente
apenas para que o sinal da morte do filho chegue e a função childhandler seja acionada, sendo que nesse print, o 
status do filho foi que ele terminou com código 9. Se o filho terminar antes do fim da "soneca" do pai, os dois prints
do filho são mostrados na tela e a childhandler é acionada, mostrando que o filho terminou com código 0 e o pai é encerrado.

-----------------------------------------------------

Questão 4) Faça um programa que cria dois processos
leitores e um processo escritor em uma mesma
pipe. Faça o escritor dormir metade do tempo
dos leitores, e mostre como os leitores
consomem os dados produzidos pelo escritor.
Obs: não force uma alternância controlada por
SIGSTOP/SIGCONT.
-----------------------------------------------------
ARQUIVO ex4.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

int main (int argc, char *argv[])
{
    int nDadosTx, nDadosRx; // quantidade de dados transmitidos/recebidos
    int fd[2]; // descritor dos pipes
    const char textoTX[] = "mensagem";
    char textoRX[sizeof textoTX];
    int pid1, pid2, status;

    if (pipe(fd) < 0)
    {
        puts ("Erro ao abrir os pipes");
        exit (-1);
    }

    if((pid1 = fork()) == 0) // filho 1 (leitor)
    {
        sleep(4);
        close(fd[1]);
        nDadosRx = read(fd[0], textoRX, sizeof textoRX);
        printf("Leitura de %d dados pelo filho 1.\nConteúdo: %s\n", nDadosRx, textoRX);
        close(fd[0]);
        exit(3);
    }
    if ((pid2 = fork()) == 0) // filho 2 (leitor)
    {
        sleep(4);
        close(fd[1]);
        nDadosRx = read(fd[0], textoRX, sizeof textoRX);
        printf("Leitura de %d dados pelo filho 2.\nConteúdo: %s\n", nDadosRx, textoRX);
        close(fd[0]);
        exit(3);
    }

    sleep(2);
    close(fd[0]);
    nDadosTx = write(fd[1], textoTX, strlen(textoTX) + 1);
    close(fd[1]);
    printf("%d dados escritos pelo pai!\n", nDadosTx);

    waitpid(-1, &status, 0);

    
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex4 ex4.c
$./ex4

-----------------------------------------------------
RESULTADO 1 (sleep 1 no pai e sleep 2 nos filhos)

9 dados escritos pelo pai!
Leitura de 0 dados pelo filho 1.
Leitura de 9 dados pelo filho 2.
Conteúdo: 
Conteúdo: mensagem

------------------------------------------------------
RESULTADO 2 (sleep 2 no pai e sleep 4 nos filhos)

9 dados escritos pelo pai!
Leitura de 9 dados pelo filho 1.
Conteúdo: mensagem
Leitura de 0 dados pelo filho 2.
Conteúdo: 

-----------------------------------------------------
CONCLUSÃO

A partir do resultado, é possível concluir que após a leitura da pipe,
não é possível reler o que já foi lido, pois o dado é removido da
pipe pelo processo que o leu.