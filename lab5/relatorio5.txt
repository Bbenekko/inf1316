Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Faça um programa para criar dois processos que se comunicam via pipe. 
O Pai lê do pipe enquanto o filho escreve no pipe. Exiba o resultado do que foi 
escrito e lido.
-----------------------------------------------------
ARQUIVO ex1.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h> 

#define TAM_VETOR 100   

int main(void)
{
    int fd[2]; /* descritor a ser duplicado */
    int qtdLidos = 0;
    int qtdEnviados = 0;
    int id;

    if (pipe(fd) < 0)
    {
        puts ("Erro ao abrir os pipes");
        exit (-1);
    }

    id = fork();
    if(id == 0) //filho
    {
        close(fd[0]); //tem que fechar leitura
        char frase[TAM_VETOR] = "Ola pai! Aqui e o seu filho. Meu pid e ";
        char idStr [10];
        sprintf(idStr, "%d", getpid());
        strcat(frase, idStr);
        qtdEnviados = write(fd[1], frase, strlen(frase) + 1);
        printf("%d dados enviados\n", qtdEnviados);
        close(fd[1]);
    }
    else if (id > 0)
    {
        close(fd[1]); //tem que fechar escrita
        char frase[TAM_VETOR];

        qtdLidos = read(fd[0], frase, TAM_VETOR);
        printf("%d dados lidos: %s\n", qtdLidos, frase);
        printf("\nAqui e o pai e o pid do filho era %d\n", id);
        close(fd[0]);
    }
    else
    {
        puts ("Erro na criação do novo processo\n");
        exit (-2);
    }

    
    return 0;
}  

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex1 ex1.c
$./ex1
-----------------------------------------------------
RESULTADO

47 dados enviados
47 dados lidos: Ola pai! Aqui e o seu filho. Meu pid e 1346261

Aqui e o pai e o pid do filho era 1346261

-----------------------------------------------------
CONCLUSÃO

No programa pai, é criado um vetor de duas posições fd e nele são guardados os descritores 
de leitura e escrita respectivamente. Após isso, é feito o fork e um processo filho é criado. 
Na parte que apenas o processo filho roda, é fechada a comunicação de leitura com a função 
close e é enviado um dado, nesse caso uma string com tamanho de 47, pelo comando write pela
comunicação de pipe na segunda posição do vetor fd. No pai, é fechada a comunicação de saída
e é usado o comando read para ler o dado presente na pipe e colocar em alguma variável, um 
vetor de string no caso específico e depois a string foi printada. Foi necessário se atentar
à quantidade de bytes que se quer escrever ou ler nos comandos read ou write. Também se 
observa que, no write, foi usado o strlen(str) + 1 para dizer o quanto de bytes da capacidade
total da string que deveria ser enviada e, no read, por mais que ele pudesse ler até 100,
o read leu exatamente a quantidade de bytes que a string passada tem.

-----------------------------------------------------

Questão 2) 
Tente fazer um programa para interceptar o
sinal SIGKILL. Você conseguiu? Explique.
-----------------------------------------------------
ARQUIVO ex2.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

#define EVER ;;

void intHandler(int sinal);
void quitHandler(int sinal);

int main (void)
{
    void (*p)(int); // ponteiro para função que recebe int como
    // parâmetro
    p = signal(SIGKILL, intHandler);
    printf("Programa rodando!\n");
    for(EVER);
}

void intHandler(int sinal)
{
    printf("Você tentou dar SIGKILL!");
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o ex2 ex2.c
$./ex2 &

-----------------------------------------------------
RESULTADO

Programa rodando!
$ps 
$kill -s 9 8422
[1]+    Killed             ./ex2

-----------------------------------------------------

CONCLUSÃO

Não foi possível interceptar o sinal SIGKILL, mesmo que no código houvesse a função signal()
com um inthandler, para alterar o sinal para um sinal "inofensivo". Foi explicado em aula
que o sinal kill não pode ser interceptado.

-----------------------------------------------------

Questão 3) Faça um programa para criar um pipe e
executar dois processos que são utilitários do Unix
que se comuniquem através do pipe criado, assim
como a shell faz. Exemplo: 

endler$ ps | wc
 28 28 310

-----------------------------------------------------
ARQUIVO ex3.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h> 

#define TAM_VETOR 100   

int main(void)
{
    int fd[2]; /* descritor a ser duplicado */
    int id;

    if (pipe(fd) < 0)
    {
        puts ("Erro ao abrir os pipes");
        exit (-1);
    }

    id = fork();
    if(id == 0) //filho
    {
        close(fd[0]); //tem que fechar leitura
        
        dup2(fd[1], 1);
        system("ps");

        close(fd[1]);
    }
    else if (id > 0)
    {
        close(fd[1]); //tem que fechar escrita

        dup2(fd[0], 0);
        system("wc");
        close(fd[0]);
    }
    else
    {
        puts ("Erro na criação do novo processo\n");
        exit (-2);
    }

    return 0;
} 
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex3 ex3.c
$./ex3
-----------------------------------------------------

RESULTADO

    7      28     209

-----------------------------------------------------

CONCLUSÃO 


No programa, após a criação dos canais de comunicação e da criação do processo filho pelo 
fork, no filho o canal de leitura é fechado e o stdout é redirecionado para a o canal de 
comunicação de escrita fd[1]. Com isso, ao usar o system("ps"), a saída desse comando vai para 
o pipe. No programa pai, o canal de leitura é fechado e o stdin é redirecionado para o canal 
de leitura fd[0]. Com isso, utilizando o entrada que já estava com o resultado do comando anterior,
o comando system("wc") atua em cima do que já estava na saída, assim como o comando na shell e 
printa a saída no terminal. Em ambos os casos, as saídas não utilizadas anteriormente foram fechadas.

-----------------------------------------------------

Questão 4) Usando SIGSTOP e SIGCONT faça um
programa que crie 2 processos filho e alterne a
execução dos filhos. Após 10 trocas de
contexto, o processo pai mata os processos
filho.
OBS: Os processos filho são formados por loops
infinitos.
-----------------------------------------------------
ARQUIVO ex4.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>

#define EVER ;;

int main()
{
    int pid1, pid2;

    printf("pid do pai = %d\n", getpid());  
    if((pid1 = fork()) == 0) // filho 1
    {
        for(EVER)
        {
            printf("Filho 1 executando!\n");
            sleep(1);
        }
    }

    printf("pid do pai = %d\n", getpid());
    if((pid2 = fork()) == 0) // filho 2
    {
        for(EVER)
        {
            printf("Filho 2 executando!\n");
            sleep(1);
        }
    }

    for (int i = 1; i < 11; i++)
    {
        if(i%2) // se i for impar 
        {
            kill(pid1, SIGSTOP);
            kill(pid2, SIGCONT);
        }
        else // se i for par
        {
            kill(pid2, SIGSTOP);
            kill(pid1, SIGCONT);
        }
        sleep(2);
    }

    printf("Terminou!");
    kill(pid1, SIGKILL);
    kill(pid2, SIGKILL);


    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex4 ex4.c
$./ex4

-----------------------------------------------------
RESULTADO

pid do pai = 8622
pid do pai = 8622
Filho 1 executando!
Filho 2 executando!
Filho 2 executando!
Filho 2 executando!
Filho 1 executando!
Filho 1 executando!
Filho 2 executando!
Filho 2 executando!
Filho 1 executando!
Filho 1 executando!
Filho 2 executando!
Filho 2 executando!
Filho 1 executando!
Filho 1 executando!
Filho 2 executando!
Filho 2 executando!
Filho 1 executando!
Filho 1 executando!
Filho 2 executando!
Filho 2 executando!
Filho 1 executando!
Filho 1 executando!
Terminou!

-----------------------------------------------------
CONCLUSÃO

Para realizar a tarefa, foram realizados dois forks (com variáveis pid1 e pid2, para o primeiro
e segundo filho respectivamente), nos quais os mesmos estão em um loop infinito, que apenas printa
que está em execução, e pausa (sleep) por um segundo. 
No processo pai, há um loop de um for, que caso seja impar para o filho 1 e continua o filho 2,
e caso seja par faz o contrário. Ambos são realizados com os sinais SIGSTOP e SIGCONT. 
APós isso há um sleep de 2 segundos Como é possível observar, no output as vezes há mais ou menos 
prints por filho, isso se dá por uma falta de sincronia entre o sleep do pai e o sleep dos processos 
filhos. No final do programa, os processos filhos são finalizados com SIGKILL.