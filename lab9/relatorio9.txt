Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Use o programa listaarquivo.c para imprimir o
numero de inode, o tamanho (em bytes) e a idade em
dias de cada arquivo do diretório corrente. Lembre-se
que stat() espera o path completo do arquivo

-----------------------------------------------------
ARQUIVO ex1.c

#define _DEFAULT_SOURCE  // garante scandir/alphasort no glibc moderno
#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <time.h>

char pathname[PATH_MAX];

#define FALSE 0
#define TRUE 1

int file_select(const struct dirent *entry)
{
    if ((strcmp(entry->d_name, ".") == 0) || (strcmp(entry->d_name, "..") == 0))
    return (FALSE);
    else
    return (TRUE);
}

/* int file_select ( struct direct *entry)
{
 char *ptr;
 char *rindex(char *s, char c);

 if ((strcmp(entry->d_name, ".")== 0) || (strcmp(entry->d_name, "..") == 0))
 return (FALSE);
 //Check for filename extensions 
 ptr = rindex(entry->d_name, '.')
 if ((ptr != NULL) && ((strcmp(ptr, ".c") == 0) || (strcmp(ptr, ".h") == 0) ||
 (strcmp(ptr, ".o") == 0) ))
return (TRUE);
 else
return(FALSE);
}  */

int main() 
{
    struct dirent **files;
    struct stat stats;
    int count;
    time_t now = time(NULL);

    if (getcwd(pathname, sizeof(pathname)) == NULL ) 
    { 
        printf("Error getting pathname\n"); 
        exit(0);
    }
    printf("Current Working Directory = %s\n",pathname);
    
    count = scandir( pathname, &files, file_select, alphasort);

    /* If no files found, make a non-selectable menu item */
    if (count <= 0) 
    { 
        printf("No files in this directory\n"); 
        exit(0);
    }

    printf("Number of files = %d\n",count);

    for (int i = 0; i < count; ++i) 
    {
        char path[PATH_MAX];
        int n = snprintf(path, sizeof(path), "%s/%s", pathname, files[i]->d_name);
        if (n < 0 || n > sizeof(path))
        {
            printf("Error getting path\n"); 
            exit(0);
        }

        if (stat(path, &stats) != 0) 
        {           
            printf("Erro ao acessar os stats");
            exit(0);
        }

        // TODO converter time para dias
        long tempo_dias = (long)(difftime(now, stats.st_mtime) / (60 * 60 * 24));

        printf("%s     inode %ld      size: %ld    age: %ld\n", files[i]->d_name, files[i]->d_ino, stats.st_size, tempo_dias);
    }

    printf("\n"); /* flush buffer */
    
    for (int i = 0; i < count; ++i) free(files[i]);
    free(files);

    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex1 ex1.c
$./ex1
-----------------------------------------------------
RESULTADO

Current Working Directory = /home/neco/Documents/sistemas_operacionais/inf1316/lab9/1e2
Number of files = 6
ex1     inode 2994142      size: 13208    age: 0
ex1.c     inode 2994143      size: 2267    age: 0
ex2     inode 2994243      size: 13208    age: 0
ex2.c     inode 2994183      size: 2298    age: 0
rickroll.txt     inode 2994145      size: 27666    age: 0
teste.txt     inode 2994146      size: 15    age: 0

-----------------------------------------------------
CONCLUSÃO

Para a realização da atividade, precisei alterar o código listaarquivo original, 
pois não consegui compilar com as bilbiotecas utilizadas (troquei para versões mais atuais).
Para adicionar o inode, basta puxar da struct dirent (antiga direct).
Para adicioanr o tamanho e os dias, precisei puxar as informações da strutura stat dos arquivos,
e assim consegui puxar essas informações. Para os dias, precisei transformar de segundos para dias,
visto que a estrutura stat guarda apenas em segundos.
Também foram criados outros arquivos (.txt) para mostrar o programa funcionando!
A age está 0 pois todos os arquivos foram criados hoje.

-----------------------------------------------------

Questão 2) 
Modifique o programa anterior para mostrar o número de
links que cada arquivo possui. Depois, no diretório
corrente, execute o o comando da shell
ln <arquivo> <nomeLink> e veja o que mudou na
saída de seu programa
-----------------------------------------------------
ARQUIVO ex2.c

#define _DEFAULT_SOURCE  // garante scandir/alphasort no glibc moderno
#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <time.h>

char pathname[PATH_MAX];

#define FALSE 0
#define TRUE 1

int file_select(const struct dirent *entry)
{
    if ((strcmp(entry->d_name, ".") == 0) || (strcmp(entry->d_name, "..") == 0))
    return (FALSE);
    else
    return (TRUE);
}

/* int file_select ( struct direct *entry)
{
 char *ptr;
 char *rindex(char *s, char c);

 if ((strcmp(entry->d_name, ".")== 0) || (strcmp(entry->d_name, "..") == 0))
 return (FALSE);
 //Check for filename extensions 
 ptr = rindex(entry->d_name, '.')
 if ((ptr != NULL) && ((strcmp(ptr, ".c") == 0) || (strcmp(ptr, ".h") == 0) ||
 (strcmp(ptr, ".o") == 0) ))
return (TRUE);
 else
return(FALSE);
}  */

int main() 
{
    struct dirent **files;
    struct stat stats;
    int count;
    time_t now = time(NULL);

    if (getcwd(pathname, sizeof(pathname)) == NULL ) 
    { 
        printf("Error getting pathname\n"); 
        exit(0);
    }
    printf("Current Working Directory = %s\n",pathname);
    
    count = scandir( pathname, &files, file_select, alphasort);

    /* If no files found, make a non-selectable menu item */
    if (count <= 0) 
    { 
        printf("No files in this directory\n"); 
        exit(0);
    }

    printf("Number of files = %d\n",count);

    for (int i = 0; i < count; ++i) 
    {
        char path[PATH_MAX];
        int n = snprintf(path, sizeof(path), "%s/%s", pathname, files[i]->d_name);
        if (n < 0 || n > sizeof(path))
        {
            printf("Error getting path\n"); 
            exit(0);
        }

        if (stat(path, &stats) != 0) 
        {           
            printf("Erro ao acessar os stats");
            exit(0);
        }

        // TODO converter time para dias
        long tempo_dias = (long)(difftime(now, stats.st_mtime) / (60 * 60 * 24));

        printf("%s     inode %ld      size: %ld    age: %ld    nLinks: %ld\n", files[i]->d_name, files[i]->d_ino, stats.st_size, tempo_dias, stats.st_nlink);
    }

    printf("\n"); /* flush buffer */
    
    for (int i = 0; i < count; ++i) free(files[i]);
    free(files);

    return 0;
}


-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o ex2 ex2.c 
$./ex2

COMPILAÇÃO E EXECUÇÃO PARTE 2
$ln teste.txt teste2
$./ex2

-----------------------------------------------------
RESULTADO 1 

Current Working Directory = /home/neco/Documents/sistemas_operacionais/inf1316/lab9/1e2
Number of files = 6
ex1     inode 2994142      size: 13208    age: 0    nLinks: 1
ex1.c     inode 2994143      size: 2267    age: 0    nLinks: 1
ex2     inode 2994243      size: 13208    age: 0    nLinks: 1
ex2.c     inode 2994183      size: 2298    age: 0    nLinks: 1
rickroll.txt     inode 2994145      size: 27666    age: 0    nLinks: 1
teste.txt     inode 2994146      size: 15    age: 0    nLinks: 1

RESULTADO 2 (Rodando o comando pedido)

Current Working Directory = /home/neco/Documents/sistemas_operacionais/inf1316/lab9/1e2
Number of files = 7
ex1     inode 2994142      size: 13208    age: 0    nLinks: 1
ex1.c     inode 2994143      size: 2267    age: 0    nLinks: 1
ex2     inode 2994243      size: 13208    age: 0    nLinks: 1
ex2.c     inode 2994183      size: 2298    age: 0    nLinks: 1
rickroll.txt     inode 2994145      size: 27666    age: 0    nLinks: 1
teste.txt     inode 2994146      size: 15    age: 0    nLinks: 2
teste2     inode 2994146      size: 15    age: 0    nLinks: 2

-----------------------------------------------------

CONCLUSÃO

É possível observar que o comando na shell criou um link entre o teste.txt e o teste2,
e o código conseguiu detectar isso, sem aparentar nenhum erro.
Para fazer essa parte, bastou pegar o nlinks da struct stat.

-----------------------------------------------------

Questão 3) Escreva um programa que percorre recursivamente um diretório, a partir 
do diretório corrente, somando o tamanho de todos os arquivos encontrados. 
-----------------------------------------------------
ARQUIVO ex3.c

#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

int percorreDirs(const char *path) {
    DIR *dir;
    struct dirent *entry;
    int total = 0;

    dir = opendir(path);
    if (!dir) {
        perror(path);
        return 0;
    }

    while ((entry = readdir(dir)) != NULL) {
        const char *name = entry->d_name;

        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
            continue;

        char pathname[MAXPATHLEN];
        snprintf(pathname, sizeof(pathname), "%s/%s", path, name);

        struct stat st;
        if (stat(pathname, &st) == -1) {
            perror(pathname);
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            total += percorreDirs(pathname);
        } 
        else {
            printf("%s: %d bytes\n", pathname, (int)st.st_size);
            total += (int)st.st_size;
        }
    }

    closedir(dir);
    return total;
}

int main() {
    int total = percorreDirs(".");
    printf("Total de bytes = %d\n", total);
    return 0;
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex3 ex3.c
$./ex3
-----------------------------------------------------

RESULTADO

Está dentro do arquivo "output_da_3.txt", pois foi muito grande, já que foram 64 elementos
processados/criados.
-----------------------------------------------------

CONCLUSÃO 

A base desse programa foi o código dado na aula "Capítulo 2 - Gerenciamento de Processos, Threads e Escalonamento".
Apenas foram feitas alterações para suportar uma fila ao invés de um buffer único (que era o
exemplo dado na aula). As saídas foram coloridas para facilitar a leitura:
- AZUL: entrada
- AMARELO: saída
- VERMELHO: warning
As alterações para a fila foram checagem se a fila está cheia (através de um variável global
que conta os espaços vazios).

-----------------------------------------------------

Questão 4) Modifique o programa anterior para mostrar
recursivamente os diretórios e arquivos aninhados. 

-----------------------------------------------------
ARQUIVO ex4.c

#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

void percorreDirs(const char *path,int nvl) {
    DIR *dir;
    struct dirent *entry;

    dir = opendir(path);
    if (!dir) {
        perror(path);
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        const char *name = entry->d_name;

        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
            continue;

        char pathname[MAXPATHLEN];
        snprintf(pathname, sizeof(pathname), "%s/%s", path, name);

        struct stat st;
        if (stat(pathname, &st) == -1) {
            perror(pathname);
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            printf("%*s[%s]\n", nvl * 2, "", name);
            percorreDirs(pathname, nvl + 1);
        } 
        else {
            printf("%*s%s\n", nvl * 2, "", name);
        }
    }

    closedir(dir);
}

int main() {
    printf("[%s]\n", ".");
    percorreDirs(".", 0);
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex4 ex4.c
$./ex4

-----------------------------------------------------
RESULTADO

Está dentro do arquivo "output_da_4.txt", pois foi muito grande, já que foram 64 elementos
processados/criados.

-----------------------------------------------------
CONCLUSÃO

O código se assemelha muito ao código anterior (questão 3), com apenas a diferença
de que a condição de loop para geração do total de elementos foi dividida sobre a 
quantidade de threads (ex: no caso de 2 threads, cada uma trabalhará apenas com uma 
metade  (1/2) do total).
O mutex não teve nenhuma mudança no código.
Vale ressaltar que esse programa foi muito mais rápido que o anterior, devido
a maior quantidade de threads trabalhando.