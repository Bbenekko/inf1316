Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Use o programa listaarquivo.c para imprimir o
numero de inode, o tamanho (em bytes) e a idade em
dias de cada arquivo do diretório corrente. Lembre-se
que stat() espera o path completo do arquivo

-----------------------------------------------------
ARQUIVO ex1.c

#define _DEFAULT_SOURCE  // garante scandir/alphasort no glibc moderno
#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <time.h>

char pathname[PATH_MAX];

#define FALSE 0
#define TRUE 1

int file_select(const struct dirent *entry)
{
    if ((strcmp(entry->d_name, ".") == 0) || (strcmp(entry->d_name, "..") == 0))
    return (FALSE);
    else
    return (TRUE);
}

/* int file_select ( struct direct *entry)
{
 char *ptr;
 char *rindex(char *s, char c);

 if ((strcmp(entry->d_name, ".")== 0) || (strcmp(entry->d_name, "..") == 0))
 return (FALSE);
 //Check for filename extensions 
 ptr = rindex(entry->d_name, '.')
 if ((ptr != NULL) && ((strcmp(ptr, ".c") == 0) || (strcmp(ptr, ".h") == 0) ||
 (strcmp(ptr, ".o") == 0) ))
return (TRUE);
 else
return(FALSE);
}  */

int main() 
{
    struct dirent **files;
    struct stat stats;
    int count;
    time_t now = time(NULL);

    if (getcwd(pathname, sizeof(pathname)) == NULL ) 
    { 
        printf("Error getting pathname\n"); 
        exit(0);
    }
    printf("Current Working Directory = %s\n",pathname);
    
    count = scandir( pathname, &files, file_select, alphasort);

    /* If no files found, make a non-selectable menu item */
    if (count <= 0) 
    { 
        printf("No files in this directory\n"); 
        exit(0);
    }

    printf("Number of files = %d\n",count);

    for (int i = 0; i < count; ++i) 
    {
        char path[PATH_MAX];
        int n = snprintf(path, sizeof(path), "%s/%s", pathname, files[i]->d_name);
        if (n < 0 || n > sizeof(path))
        {
            printf("Error getting path\n"); 
            exit(0);
        }

        if (stat(path, &stats) != 0) 
        {           
            printf("Erro ao acessar os stats");
            exit(0);
        }

        // TODO converter time para dias
        long tempo_dias = (long)(difftime(now, stats.st_mtime) / (60 * 60 * 24));

        printf("%s     inode %ld      size: %ld    age: %ld\n", files[i]->d_name, files[i]->d_ino, stats.st_size, tempo_dias);
    }

    printf("\n"); /* flush buffer */
    
    for (int i = 0; i < count; ++i) free(files[i]);
    free(files);

    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex1 ex1.c
$./ex1
-----------------------------------------------------
RESULTADO

Current Working Directory = /home/neco/Documents/sistemas_operacionais/inf1316/lab9/1e2
Number of files = 6
ex1     inode 2994142      size: 13208    age: 0
ex1.c     inode 2994143      size: 2267    age: 0
ex2     inode 2994243      size: 13208    age: 0
ex2.c     inode 2994183      size: 2298    age: 0
rickroll.txt     inode 2994145      size: 27666    age: 0
teste.txt     inode 2994146      size: 15    age: 0

-----------------------------------------------------
CONCLUSÃO

Para a realização da atividade, precisei alterar o código listaarquivo original, 
pois não consegui compilar com as bilbiotecas utilizadas (troquei para versões mais atuais).
Para adicionar o inode, basta puxar da struct dirent (antiga direct).
Para adicioanr o tamanho e os dias, precisei puxar as informações da strutura stat dos arquivos,
e assim consegui puxar essas informações. Para os dias, precisei transformar de segundos para dias,
visto que a estrutura stat guarda apenas em segundos.
Também foram criados outros arquivos (.txt) para mostrar o programa funcionando!
A age está 0 pois todos os arquivos foram criados hoje.

-----------------------------------------------------

Questão 2) 
Modifique o programa anterior para mostrar o número de
links que cada arquivo possui. Depois, no diretório
corrente, execute o o comando da shell
ln <arquivo> <nomeLink> e veja o que mudou na
saída de seu programa
-----------------------------------------------------
ARQUIVO ex2.c

#define _DEFAULT_SOURCE  // garante scandir/alphasort no glibc moderno
#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <time.h>

char pathname[PATH_MAX];

#define FALSE 0
#define TRUE 1

int file_select(const struct dirent *entry)
{
    if ((strcmp(entry->d_name, ".") == 0) || (strcmp(entry->d_name, "..") == 0))
    return (FALSE);
    else
    return (TRUE);
}

/* int file_select ( struct direct *entry)
{
 char *ptr;
 char *rindex(char *s, char c);

 if ((strcmp(entry->d_name, ".")== 0) || (strcmp(entry->d_name, "..") == 0))
 return (FALSE);
 //Check for filename extensions 
 ptr = rindex(entry->d_name, '.')
 if ((ptr != NULL) && ((strcmp(ptr, ".c") == 0) || (strcmp(ptr, ".h") == 0) ||
 (strcmp(ptr, ".o") == 0) ))
return (TRUE);
 else
return(FALSE);
}  */

int main() 
{
    struct dirent **files;
    struct stat stats;
    int count;
    time_t now = time(NULL);

    if (getcwd(pathname, sizeof(pathname)) == NULL ) 
    { 
        printf("Error getting pathname\n"); 
        exit(0);
    }
    printf("Current Working Directory = %s\n",pathname);
    
    count = scandir( pathname, &files, file_select, alphasort);

    /* If no files found, make a non-selectable menu item */
    if (count <= 0) 
    { 
        printf("No files in this directory\n"); 
        exit(0);
    }

    printf("Number of files = %d\n",count);

    for (int i = 0; i < count; ++i) 
    {
        char path[PATH_MAX];
        int n = snprintf(path, sizeof(path), "%s/%s", pathname, files[i]->d_name);
        if (n < 0 || n > sizeof(path))
        {
            printf("Error getting path\n"); 
            exit(0);
        }

        if (stat(path, &stats) != 0) 
        {           
            printf("Erro ao acessar os stats");
            exit(0);
        }

        // TODO converter time para dias
        long tempo_dias = (long)(difftime(now, stats.st_mtime) / (60 * 60 * 24));

        printf("%s     inode %ld      size: %ld    age: %ld    nLinks: %ld\n", files[i]->d_name, files[i]->d_ino, stats.st_size, tempo_dias, stats.st_nlink);
    }

    printf("\n"); /* flush buffer */
    
    for (int i = 0; i < count; ++i) free(files[i]);
    free(files);

    return 0;
}


-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o ex2 ex2.c 
$./ex2

COMPILAÇÃO E EXECUÇÃO PARTE 2
$ln teste.txt teste2
$./ex2

-----------------------------------------------------
RESULTADO 1 

Current Working Directory = /home/neco/Documents/sistemas_operacionais/inf1316/lab9/1e2
Number of files = 6
ex1     inode 2994142      size: 13208    age: 0    nLinks: 1
ex1.c     inode 2994143      size: 2267    age: 0    nLinks: 1
ex2     inode 2994243      size: 13208    age: 0    nLinks: 1
ex2.c     inode 2994183      size: 2298    age: 0    nLinks: 1
rickroll.txt     inode 2994145      size: 27666    age: 0    nLinks: 1
teste.txt     inode 2994146      size: 15    age: 0    nLinks: 1

RESULTADO 2 (Rodando o comando pedido)

Current Working Directory = /home/neco/Documents/sistemas_operacionais/inf1316/lab9/1e2
Number of files = 7
ex1     inode 2994142      size: 13208    age: 0    nLinks: 1
ex1.c     inode 2994143      size: 2267    age: 0    nLinks: 1
ex2     inode 2994243      size: 13208    age: 0    nLinks: 1
ex2.c     inode 2994183      size: 2298    age: 0    nLinks: 1
rickroll.txt     inode 2994145      size: 27666    age: 0    nLinks: 1
teste.txt     inode 2994146      size: 15    age: 0    nLinks: 2
teste2     inode 2994146      size: 15    age: 0    nLinks: 2

-----------------------------------------------------

CONCLUSÃO

É possível observar que o comando na shell criou um link entre o teste.txt e o teste2,
e o código conseguiu detectar isso, sem aparentar nenhum erro.
Para fazer essa parte, bastou pegar o nlinks da struct stat.

-----------------------------------------------------

Questão 3) Escreva um programa que percorre recursivamente um diretório, a partir 
do diretório corrente, somando o tamanho de todos os arquivos encontrados. 
-----------------------------------------------------
ARQUIVO ex3.c

#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

int percorreDirs(const char *path) {
    DIR *dir;
    struct dirent *entry;
    int total = 0;

    dir = opendir(path);
    if (!dir) {
        perror(path);
        return 0;
    }

    while ((entry = readdir(dir)) != NULL) {
        const char *name = entry->d_name;

        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
            continue;

        char pathname[MAXPATHLEN];
        snprintf(pathname, sizeof(pathname), "%s/%s", path, name);

        struct stat st;
        if (stat(pathname, &st) == -1) {
            perror(pathname);
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            total += percorreDirs(pathname);
        } 
        else {
            printf("%s: %d bytes\n", pathname, (int)st.st_size);
            total += (int)st.st_size;
        }
    }

    closedir(dir);
    return total;
}

int main() {
    int total = percorreDirs(".");
    printf("Total de bytes = %d\n", total);
    return 0;
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex3 ex3.c
$./ex3
-----------------------------------------------------

RESULTADO

./ex3: 16336 bytes
./teste/a.txt: 3 bytes
./teste/sub/c.txt: 3 bytes
./teste/b.txt: 5 bytes
./ex4: 16336 bytes
./ex3.c: 1173 bytes
./ex4.c: 1116 bytes
Total de bytes = 34972
-----------------------------------------------------

CONCLUSÃO 

No código, foi criada uma função recursiva chamada percorreDirs que recebe o nome do diretório,
por isso na main foi passado o '.' que representa o diretório atual. Com isso, é criado um 
stream de diretório com a função "opendir" e depois é feito um while com a função "readdir" 
que uma entrada do diretório por vez e retorna uma struct dirent que contém o nome do objeto 
no campo d_name. Esse while serve para olhar o que tem dentro do diretório que não seja outro diretório.
Com isso, é utilizado o snprintf para criar o caminho total usando o path + o nome do arquivo/diretório no molde correto. Com o caminho todo, usa-se a função stat que contém as 
informações do arquivo/diretório. Depois há um if que vê se é realmente um arquivo ou se é um diretório.
Foi escolhida essa forma de escrever pois a do exemplo no material era antiga e o vs code considerava como
erro, então esse novo modo foi utilizado para driblar esse problema. Se for um diretório, a própria 
função é chamada novamente e a variável total é acrescida com o valor que a função retorna. Se não 
for um diretório, ele apenas printa o caminho do arquivo e soma a quantidade de bytes com o total já existente.
Depois o stream de diretório é fechado e o valor total retornado. Portanto, a recursão foi utilizada
Para percorrer os diretórios que estão dentro de outros diretórios. 

-----------------------------------------------------

Questão 4) Modifique o programa anterior para mostrar
recursivamente os diretórios e arquivos aninhados. 

-----------------------------------------------------
ARQUIVO ex4.c

#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

void percorreDirs(const char *path,int nvl) {
    DIR *dir;
    struct dirent *entry;

    dir = opendir(path);
    if (!dir) {
        perror(path);
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        const char *name = entry->d_name;

        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
            continue;

        char pathname[MAXPATHLEN];
        snprintf(pathname, sizeof(pathname), "%s/%s", path, name);

        struct stat st;
        if (stat(pathname, &st) == -1) {
            perror(pathname);
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            printf("%*s[%s]\n", nvl * 2, "", name);
            percorreDirs(pathname, nvl + 1);
        } 
        else {
            printf("%*s%s\n", nvl * 2, "", name);
        }
    }

    closedir(dir);
}

int main() {
    printf("[%s]\n", ".");
    percorreDirs(".", 0);
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex4 ex4.c
$./ex4

-----------------------------------------------------
RESULTADO

[.]
ex3
[teste]
  a.txt
  [sub]
    c.txt
  b.txt
ex4
ex3.c
ex4.c

-----------------------------------------------------
CONCLUSÃO

O código da questão 4 é muito semelhante ao da três, com a diferença que agora também se passa o nível
como parâmetro para poder printar de modo adequado: Toda vez que for um diretório, o nível passado
como parâmetro é acrescentado em +1 e é utilizado no printf para dar espaços nas laterais e assim mostrar 
os níveis aninhados.