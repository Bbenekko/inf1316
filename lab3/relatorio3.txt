Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Execute o programa “ctrl-c.c”.
Digite Ctrl-C e Ctrl-\. Analise o resultado.

Neste mesmo programa, remova os
comandos signal( ) e repita o teste anterior
observando os resultados.
-----------------------------------------------------
ARQUIVO ex1.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

#define EVER ;;
void intHandler(int sinal);
void quitHandler(int sinal);

int main (void)
{
void (*p)(int); // ponteiro para função que recebe int como
    // parâmetro
    p = signal(SIGINT, intHandler);
    printf("Endereco do manipulador anterior %p\n", p);
    p = signal(SIGQUIT, quitHandler);
    printf("Endereco do manipulador anterior %p\n", p);
    puts ("Ctrl-C desabilitado. Use Ctrl-\\ para terminar");
    for(EVER);
}
void intHandler(int sinal)
{
    printf("Você pressionou Ctrl-C (%d) \n", sinal);
}
void quitHandler(int sinal)
{
    printf("Terminando o processo...\n");
    exit (0);
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ctrl-c ctrl-c.c
$./ctrl-c
-----------------------------------------------------
RESULTADO 1

Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^CVocê pressionou Ctrl-C (2) 
^CVocê pressionou Ctrl-C (2) 
^CVocê pressionou Ctrl-C (2) 
^\Terminando o processo...

RESULTADO 2

Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^C

-----------------------------------------------------
CONCLUSÃO

No programa original, a função signal foi utilizada duas vezes, de modo que na primeira vez ela captura
o sinal SIGINT que é recebido quando se escrever ctrl-c na shell enquanto roda um programa para interrompê-lo 
e na segunda vez ele captura o sinal SIGQUIT que também interrompre o programa, mas ele gera um core dump. 
Na captura do ctrl-c, ele passa a chamar a função intHandler que printa uma mensagem e na com ctrl-\, ela
printa uma mensagem e dá um exit no programa. Com isso, ao tratar o sinal de ctrl-c, ele já não afeta mais o 
programa, ou seja, ao usar ctrl-c no terminal, o programa já não é mais terminado, mas printa a mensagem da
função intHandler já que ela foi cadastrada como a reação, o que deve ser feito quando esse sinal é recebido. 
Ao usar ctrl-\, o programa é terminado, mas não da forma que normalmente aconteceria: a função quitHandler é 
acionada, o que faz com que, ao terminar o programa com um exit(0), não há criação de um core dump.

Quando se remove os comandos signal(), tanto o ctrl-c, quanto o ctrl-\ encerram o programa do jeito padrão: o 
ctrl-c interrompendo e o ctrl-\ criando o core dump.

-----------------------------------------------------

Questão 2) Mensagem do Dia
Faça um programa que:
Leia uma mensagem do dia do stdin (ou arquivo);

Crie uma memória compartilhada com a chave 8752;

Salve a mensagem na memória;

Faça um outro programa “cliente” que utilize a mesma chave (8752)
e exiba a mensagem do dia para o usuário.
-----------------------------------------------------
ARQUIVO ex2.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[])
{
    int segmento;
    FILE* arq;
    char* aux;

    // aloca a memória compartilhada
    segmento = shmget (8752, 100, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);

    // associa a memória compartilhada ao processo
    aux = (char *) shmat (segmento, 0, 0); // comparar o retorno com -1
    
    arq = fopen("arq_ex2.txt", "r");
    fgets(aux, 100, arq);
    fclose(arq);

    printf("Conteudo inserido em aux:\n %s\n", aux);

    shmdt(aux);

    // libera a memória compartilhada do processo
    //shmdt (aux);

    // libera a memória compartilhada
    //shmctl (segmento, IPC_RMID, 0);
    
    return 0;
}

ARQUIVO ex2out.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[])
{
    int segmento;
    char* aux;

    // aloca a memória compartilhada
    segmento = shmget (8752, 100, S_IRUSR | S_IWUSR);

    // associa a memória compartilhada ao processo
    aux = (char *) shmat (segmento, 0, 0); // comparar o retorno com -1

    printf("Conteudo lido de aux:\n %s\n", aux);

    // libera a memória compartilhada do processo
    shmdt (aux);

    // libera a memória compartilhada
    shmctl (segmento, IPC_RMID, 0);
    
    return 0;
}

ARQUIVO arq_ex2.txt

Mensagem do dia: "O ignorante afirma, o sábio duvida, o sensato reflete." - Aristoteles

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o ex2 ex2.c
$./ex2

-----------------------------------------------------
RESULTADO

Conteudo inserido em aux:
 Mensagem do dia: "O ignorante afirma, o sábio duvida, o sensato reflete." - Aristoteles

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 2

$gcc -Wall -o ex2out ex2out.c
$./ex2out

-----------------------------------------------------
RESULTADO

Conteudo lido de aux:
 Mensagem do dia: "O ignorante afirma, o sábio duvida, o sensato reflete." - Aristoteles

-----------------------------------------------------
CONCLUSÃO

No arquivo "ex2.c" é alocado um espaço de memória compartilhada, 
onde é salva a mensagem dentro do arquivo "arq_ex2.txt". Após isso é usado
a função shmdt() que da "detach" da memória, para que a mesma possa ser 
acessada por outros processos.
Já no arquivo "ex2out.c" é alocado um espaço de memória (retirando as 
flags IPC_CREAT e IPC_EXCL, pois a chave já existe) já populado pelo 
programa anterior. Então é extraída a mensagem do espaço de memória compartilhada 
e a mesma (mensagem) é printada no terminal. Após isso, a memória compartilhada é liberada.

-----------------------------------------------------

Questão 3) Busca paralela em vetor
Faça um programa paralelo (com pelo menos 4 processos) para localizar 
uma chave em um vetor.

Crie uma memória compartilhada com dados numéricos inteiros e desordenados e a divida
pelo número de processos;

Cada processo deve procurar o dado na sua área de memória e informar a posição onde o
dado foi localizado. 
-----------------------------------------------------
ARQUIVO filhocidio.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>

void childhandler(int signo);
int delay;
int main (int argc, char *argv[])
{
    pid_t pid;
    signal(SIGCHLD, childhandler);
    if ((pid = fork()) < 0)
    {
        fprintf(stderr, "Erro ao criar filho\n");
        exit(-1);
    }
    if (pid == 0) /* child */
        execve(argv[2], 0, 0); /* ou sleep(3);*/
    else /* parent */
    {
        sscanf(argv[1], "%d", &delay); /* read delay from command line */
        sleep(delay);
        printf("Program %s exceeded limit of %d seconds!\n", argv[2], delay);
        kill(pid, SIGKILL);
        sleep(1); /* necessary for SIGCHLD to arrive */
    }
    return 0;
}

void childhandler(int signo) /* Executed if child dies before parent */
{
    int status;
    pid_t pid = wait(&status);
    printf("Child %d terminated within %d seconds com estado %d.\n", pid, delay, status);
    exit(0);
}


ARQUIVO sleep5.c

#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    printf(stdout, "Acordei!\n");
    return 0;
}


ARQUIVO sleep15.c

#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    printf(stdout, "Acordei!\n");
    return 0;
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o sleep5 sleep5.c
$gcc -Wall -o sleep15 sleep15.c
$gcc -Wall -o filhocidio filhocidio.c
$./filhocidio 10 ./sleep5
$./filhocidio 10 ./sleep15
-----------------------------------------------------

RESULTADO

indo dormir...
Acordei!
Child 8296 terminated within 10 seconds com estado 0.

----

indo dormir...
Program ./sleep15 exceeded limit of 10 seconds!
Child 8360 terminated within 10 seconds com estado 9.
-----------------------------------------------------

CONCLUSÃO 

Tanto os programas sleep5 e sleep 15 funcionam de forma semelhante: Assim que começam a rodar, 
printam uma mensagem, são pausados por uma determinada quantidade de segundos e printam mais  uma mensagem. 

O filhocidio inicia utilizando a função signal que cadastra uma reação ao recebimento do sinal do tipo SIGCHLD
que é emitido quando há a pausa, continuidade ou a morte de um filho antes do pai. A reação criada foi a função
childhandler que é chamada quando há o recebimento desse sinal. Nela, o pai recebe o status do processo pelo wait
e printa as informações do processo fiho. 

Voltando ao código, é criado um filho no fork. Foram usados 2 programas filhos: sleep5 e sleep 15 em que cada um
printa uma mensagem, "dorme" por 5 e 15 segundos respectivamente e depois printam outra mensagem.  

Enquanto o filho roda, o pai "dorme" por uma quantidade de segundos determinada por um parâmetro passado pela linha
de comando. Se o programa filho, que até então estava rodando em paralelo, não morrer antes que a "soneca" do pai
termine, ele printa a quantidade de tempo até então e mata o filho com o comando kill, e depois "dorme" novamente
apenas para que o sinal da morte do filho chegue e a função childhandler seja acionada, sendo que nesse print, o 
status do filho foi que ele terminou com código 9. Se o filho terminar antes do fim da "soneca" do pai, os dois prints
do filho são mostrados na tela e a childhandler é acionada, mostrando que o filho terminou com código 0 e o pai é encerrado.

-----------------------------------------------------

Questão 4) Multiplicação multi-processo
Faça um programa que:
Tenha um processo pai que abre dois blocos de memória compartilhada, m1 e m2;

Cria dois processos filho (use exec), P1 e P2: estes também fazem attach em m1
ou m2 respectivamente;

Cada um dá um sleep() randômico e escreve um valor int na área compartilhada dele,
e avisa o processo pai que um novo valor foi gerado, escrevendo tb um nr de sequencia;

O pai fica em loop verificando se houve um novo valor.Apenas quando ambos P1 e P2 geraram
um novo valor, o pai imprime o produto 
O pai fica em loop verificando se houve um novo valor.Apenas quando ambos P1 e P2 geraram
um novo valor, o pai imprime o produto dos valores gerados por P1 e P2.
-----------------------------------------------------
ARQUIVO ex4.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct bloco 
{
  int valor;
  int seq;
} bloco;

int main (int argc, char *argv[])
{
    int segmento1, segmento2, id, id2, pid, status;
    __key_t chave1 = 8751;
    __key_t chave2 = 8752;

    // aloca a memória compartilhada
    segmento1 = shmget (chave1, sizeof (bloco), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);

    // associa a memória compartilhada ao processo
    bloco* m1 = (bloco *) shmat (segmento1, 0, 0); // comparar o retorno com -1
    m1->valor = 0;
    m1->seq = 0;


    segmento2 = shmget (chave2, sizeof (bloco), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    bloco* m2 = (bloco *) shmat (segmento2, 0, 0);
    m2->valor = 0;
    m2->seq = 0;

    int valoresAntigos[] = {m1->seq, m2->seq};
    char* chaves[] = {"1", "2"};

    // PODE SER FEITO COM IF
    // Porém preferi fazer com for porque fica mais clean!
    printf("pid do pai = %d\n", getpid());
    for (int i = 0; i < 2; i++)
    {
        if ((id = fork()) == 0) // proccesso filho
        {
            printf("Executando arquivo auxiliar com filho %d de pid %d\n", i+1, getpid());
            execle("ex4aux", chaves[i], NULL, (char *)0);
        }
        else if (id < 0)
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
    }

    while((m1->seq == valoresAntigos[0])|(m2->seq == valoresAntigos[1]))
    {
        sleep(1);
        printf("Processo pai aguardando resultado!\n");
    }

    printf("Resultados:\nm1: %d\nm2: %d\n", m1->valor, m2->valor);


    // libera a memória compartilhada do processo
    shmdt (m1);
    shmdt (m2);

    // libera a memória compartilhada
    shmctl (segmento1, IPC_RMID, 0);
    shmctl (segmento2, IPC_RMID, 0);
    
    return 0;
}

-----------------------------------------------------

ARQUIVO ex4aux.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct bloco 
{
  int valor;
  int seq;
} bloco;

int main(int argc, char *argv[])
{
    int segmento;
    __key_t chave1 = 8751;
    __key_t chave2 = 8752;

    // adicionando randomização "verdadeira"
    time_t t;
    srand((unsigned) time(&t));

    if(strcmp(argv[0], "1"))
    {
        segmento = shmget (chave1, sizeof (bloco), S_IRUSR | S_IWUSR);
        bloco* p = (bloco *) shmat (segmento, 0, 0);

        sleep(rand() % 10 + 2);
        p->valor = rand() % 100 + 1;

        p->seq++;

        shmdt (p);

        printf("Processo de m1 finalizado!\n");
    }
    else if (strcmp(argv[0], "2"))
    {
        segmento = shmget (chave2, sizeof (bloco), S_IRUSR | S_IWUSR);
        bloco* p = (bloco *) shmat (segmento, 0, 0);

        int aux = rand();
        srand(aux); // mudando a seed de random, já que ambos processos são realizados ao mesmo tempo, então sempre tem o mesmo resultado
        sleep(rand() % 10 + 2);
        p->valor = rand() % 100 + 1;

        p->seq++;

        shmdt (p);
        printf("Processo de m2 finalizado!\n");
    }
    else
    {
        puts ("Erro ao adquirir a chave");
        exit (-2);
    }

    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO INSTANCIA 1
$gcc -Wall -o ex4 ex4.c
$gcc -Wall -o ex4aux ex4aux.c
$./ex4

-----------------------------------------------------
RESULTADO

pid do pai = 7410
Executando arquivo auxiliar com filho 1 de pid 7411
Executando arquivo auxiliar com filho 2 de pid 7412
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo de m1 finalizado!
Processo de m2 finalizado!
Processo pai aguardando resultado!
Resultados:
m1: 33
m2: 22

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO INSTANCIA 2
$gcc -Wall -o ex4 ex4.c
$gcc -Wall -o ex4aux ex4aux.c
$./ex4

-----------------------------------------------------
RESULTADO

pid do pai = 10273
Executando arquivo auxiliar com filho 1 de pid 10274
Executando arquivo auxiliar com filho 2 de pid 10275
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo de m1 finalizado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo de m2 finalizado!
Processo pai aguardando resultado!
Resultados:
m1: 5
m2: 100

-----------------------------------------------------
CONCLUSÃO

No programa "ex4.c" foi criado o struct bloco, que contém um valor e um 
número sequencial (ambos inteiros). Então foi alocado dois blocos 
de memória compartilhada m1 e m2, que cada um é do tamanho de um struct bloco. 
Após isso, é realizado um loop que cria dois processos filhos, nos 
quais os mesmos executam o programa "ex4aux.c", com o argumento 
"1" ou "2", dependendo de qual filho seja. Após isso há 
um while (do processo pai) que verifica se ambos os números 
sequencias de m1 e m2 foram alterados, e enquanto não forem printa 
no terminal "processo pai aguardando!", com intervalos (através de um sleep) 
de 1 segundo. Após ambos sequenciais serem alterados, é printado no terminal 
os valores de m1 e m2 (alterados pelo arquivo "ex4aux.c). Ao fim, 
é liberada toda memória dos blocos.

No programa "ex4aux.c", também foi criado o struct bloco. Após isso, 
é pego o tempo, e utiliza-se o mesmo como uma seed para a função
random, deixando a próxima de uma função randômica "verdadeira".
Após isso, há um if que verifica se o argumento foi "1" ou "2": 
Caso "1", há um sleep de 2 a 11 segundos, e então é colocado um inteiro 
aleatório (de 1 a 100) dentro do valor do bloco dentro de m1, 
e é incrementado 1 no sequencial do bloco m1. 
O mesmo ocorre no caso "2", porém no mesmo a seed do random é alterada 
pelo próprio random, pois caso ambos processos sejam realizados ao mesmo 
tempo, haverão valores iguais nos blocos m1 e m2. Após isso ambos os 
casos printam que foram finalizados e o programa retorna 0.