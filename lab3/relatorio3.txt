Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Soma de matrizes
Faça um programa para somar matrizes de acordo com o seguinte algoritmo:
O primeiro processo irá criar duas matrizes preenchidas e uma terceira vazia
em 3 áreas de memória compartilhada.

Para cada linha da matriz solução, o seu programa deverá gerar um processo para
o seu cálculo.

OBS: implemente as matrizes como vetores de tamanho (linha x coluna) e aloque
a shared memory para os vetores correspondentes, pois acessar os elementos (i,j)
é complexo.

Filho 1  |5 7 9|   |5 3 0|    |10 10 9| 
Filho 2  |6 3 6| + |6 2 6| =  |12 5 12| 
Filho 3  |3 1 2|   |5 7 0|    |8  8  2| 
-----------------------------------------------------
ARQUIVO ex1.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

#define MANUAL 0

void printaMatriz(int i, int j, int* m)
{
    for (int k = 0; k < i; k++)
    {
        for(int l = 0; l < j; l++)
        {
            printf("%d ", *m);
            m++;
        }
        printf("\n");
    }
    printf("\n");
}


int main (int argc, char *argv[])
{
    int mv1, mv2, mv3, *v1r, *v2r, *v3r, *v1, *v2, *v3, id, status;

    int i, j; //i -> linha // j -> coluna 

    #if MANUAL == 1  
    printf("Insira a qtd de linhas: ");
    scanf("%d", &i);
    printf("\n");

    printf("\nInsira a qtd de colunas: ");
    scanf("%d", &j); 
    #else
    int v1p[] = {5,7,9,6,3,6,3,1,2};
    int v2p[] = {5,3,0,6,2,6,5,7,0};
    i = 3;
    j = 3;
    #endif


    mv1 = shmget (IPC_PRIVATE, sizeof (int) * i * j, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IWGRP);
    mv2 = shmget (IPC_PRIVATE, sizeof (int) * i * j, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IWGRP);
    mv3 = shmget (IPC_PRIVATE, sizeof (int) * i * j, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IWGRP);

    // associa a memória compartilhada ao processo
    v1 = (int *) shmat (mv1, 0, 0); // comparar o retorno com -1
    v2 = (int *) shmat (mv2, 0, 0); // comparar o retorno com -1
    v3 = (int *) shmat (mv3, 0, 0); // comparar o retorno com -1

    v1r = v1;
    v2r = v2;
    v3r = v3;    

    #if MANUAL == 1  
    printf("Insira os numeros da primeira matriz: ");
    #endif
    for (int l = 0; l < i * j; l++)
    {
        #if MANUAL == 1  
        scanf("%d", v1 + l);
        #else
        v1[l] = v1p[l];
        #endif
    }

    #if MANUAL == 1  
    printf("Insira os numeros da segunda matriz: ");
    #endif
    for (int l = 0; l < i * j; l++)
    {
        #if MANUAL == 1  
        scanf("%d", v2 + l);
        #else
        v2[l] = v2p[l];
        #endif
    }
    printf("\n");
    printaMatriz(i, j, v1r);       
    printaMatriz(i, j, v2r);    
 
    for(int l = 0; l < i; l++)
    {
        if (l != 0)
        {
            v1 += j;
            v2 += j;
            v3 += j;
        }
        id = fork();   
        if (id < 0)
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
        else if (id == 0)
        {
            printf(" filho: id do fork: %d // pid proprio: %d // pid do pai: %d\n", id, getpid(), getppid());
            for(int m = 0; m < j; m++)
            {
                *v3 = *v1 + *v2;
                printf("%d + %d = %d \n", *v1, *v2, *v3);
                v3++;
                v2++;
                v1++;
            }
            printf("\n");
            exit(0);
        }
    }

    for(int l = 0; l < i; l++)
    {    
        wait(&status);             
    }
    printf("pai: pid proprio: %d \n", getpid());
    printaMatriz(i, j, v3r);  
    // libera a memória compartilhada do processo
    shmdt (v1r);
    shmdt (v2r);
    shmdt (v3r);

    // libera a memória compartilhada
    shmctl (mv1, IPC_RMID, 0);
    shmctl (mv2, IPC_RMID, 0);
    shmctl (mv3, IPC_RMID, 0);
    
    return 0;
}
-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex1 ex1.c
$./ex1
-----------------------------------------------------
RESULTADO

5 7 9 
6 3 6 
3 1 2 

5 3 0 
6 2 6 
5 7 0 

filho: id do fork: 0 // pid proprio: 1233965 // pid do pai: 1233964
5 + 5 = 10 
7 + 3 = 10 
9 + 0 = 9 

filho: id do fork: 0 // pid proprio: 1233966 // pid do pai: 1233964
6 + 6 = 12 
3 + 2 = 5 
6 + 6 = 12 

filho: id do fork: 0 // pid proprio: 1233967 // pid do pai: 1233964
3 + 5 = 8 
1 + 7 = 8 
2 + 0 = 2 

pai: pid proprio: 1233964 
10 10 9 
12 5 12 
8 8 2 
-----------------------------------------------------
CONCLUSÃO

No programa, foram alocadas 3 áreas na memória compartilhada do tamanho
da quantidade de elementos da matriz. O programa foi inteiro pensado e criado
para matrizes de qualquer tamanho de forma que se pode escolher entre o modo 
manual ou não pelo define MANUAL em que, se for 0, ele vai usar a matriz dada
como exemplo e, se for 1, ele vai somar as matrizes de tamanho e valores que o 
usuário escolher. Com isso, para cada linha, é criado um novo processo que faz 
a soma índice a índice das matrizes. Para essa soma funcionar pegando os índices 
corretos, antes do fork o ponteiro para o vetor é acrescentado com a quantidade de
colunas para que o próximo processo a ser criado esteja modificado e o novo processo
possa fazer as operações nos índices corretos. Nos processos, cada um pega o conteúdo
apontado pelos vetores, soma, guarda o resultado em um outro vetor e incrementa o vetor em 1
para andar pelo vetor. A alteração do conteúdo apontado é feita perfeitamente, diferentemente do
acréscimo ao vetor que só tem efeito dentro do processo que não são variáveis na memória 
compartilhada, e sim que apenas guardam endereços dessa área. Por isso foi necessária a 
atualização dos ponteiros antes do fork. Como houve alteração dos poteiros para os vetores, foram
criados vetores reservas (v1r, v2r e v3r) que guardam o valor original e a liberação de memória é
feita com eles. Como mostra a saída, cada filho fez a soma
e no final é mostrada a matriz resultante. 
-----------------------------------------------------

Questão 2) Mensagem do Dia
Faça um programa que:
Leia uma mensagem do dia do stdin (ou arquivo);

Crie uma memória compartilhada com a chave 8752;

Salve a mensagem na memória;

Faça um outro programa “cliente” que utilize a mesma chave (8752)
e exiba a mensagem do dia para o usuário.
-----------------------------------------------------
ARQUIVO ex2.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[])
{
    int segmento;
    FILE* arq;
    char* aux;

    // aloca a memória compartilhada
    segmento = shmget (8752, 100, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);

    // associa a memória compartilhada ao processo
    aux = (char *) shmat (segmento, 0, 0); // comparar o retorno com -1
    
    arq = fopen("arq_ex2.txt", "r");
    fgets(aux, 100, arq);
    fclose(arq);

    printf("Conteudo inserido em aux:\n %s\n", aux);

    shmdt(aux);

    // libera a memória compartilhada do processo
    //shmdt (aux);

    // libera a memória compartilhada
    //shmctl (segmento, IPC_RMID, 0);
    
    return 0;
}

ARQUIVO ex2out.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[])
{
    int segmento;
    char* aux;

    // aloca a memória compartilhada
    segmento = shmget (8752, 100, S_IRUSR | S_IWUSR);

    // associa a memória compartilhada ao processo
    aux = (char *) shmat (segmento, 0, 0); // comparar o retorno com -1

    printf("Conteudo lido de aux:\n %s\n", aux);

    // libera a memória compartilhada do processo
    shmdt (aux);

    // libera a memória compartilhada
    shmctl (segmento, IPC_RMID, 0);
    
    return 0;
}

ARQUIVO arq_ex2.txt

Mensagem do dia: "O ignorante afirma, o sábio duvida, o sensato reflete." - Aristoteles

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o ex2 ex2.c
$./ex2

-----------------------------------------------------
RESULTADO

Conteudo inserido em aux:
 Mensagem do dia: "O ignorante afirma, o sábio duvida, o sensato reflete." - Aristoteles

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 2

$gcc -Wall -o ex2out ex2out.c
$./ex2out

-----------------------------------------------------
RESULTADO

Conteudo lido de aux:
 Mensagem do dia: "O ignorante afirma, o sábio duvida, o sensato reflete." - Aristoteles

-----------------------------------------------------
CONCLUSÃO

No arquivo "ex2.c" é alocado um espaço de memória compartilhada, 
onde é salva a mensagem dentro do arquivo "arq_ex2.txt". Após isso é usado
a função shmdt() que da "detach" da memória, para que a mesma possa ser 
acessada por outros processos.
Já no arquivo "ex2out.c" é alocado um espaço de memória (retirando as 
flags IPC_CREAT e IPC_EXCL, pois a chave já existe) já populado pelo 
programa anterior. Então é extraída a mensagem do espaço de memória compartilhada 
e a mesma (mensagem) é printada no terminal. Após isso, a memória compartilhada é liberada.

-----------------------------------------------------

Questão 3) Busca paralela em vetor
Faça um programa paralelo (com pelo menos 4 processos) para localizar 
uma chave em um vetor.

Crie uma memória compartilhada com dados numéricos inteiros e desordenados e a divida
pelo número de processos;

Cada processo deve procurar o dado na sua área de memória e informar a posição onde o
dado foi localizado. 
-----------------------------------------------------
ARQUIVO filhocidio.c

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>

void childhandler(int signo);
int delay;
int main (int argc, char *argv[])
{
    pid_t pid;
    signal(SIGCHLD, childhandler);
    if ((pid = fork()) < 0)
    {
        fprintf(stderr, "Erro ao criar filho\n");
        exit(-1);
    }
    if (pid == 0) /* child */
        execve(argv[2], 0, 0); /* ou sleep(3);*/
    else /* parent */
    {
        sscanf(argv[1], "%d", &delay); /* read delay from command line */
        sleep(delay);
        printf("Program %s exceeded limit of %d seconds!\n", argv[2], delay);
        kill(pid, SIGKILL);
        sleep(1); /* necessary for SIGCHLD to arrive */
    }
    return 0;
}

void childhandler(int signo) /* Executed if child dies before parent */
{
    int status;
    pid_t pid = wait(&status);
    printf("Child %d terminated within %d seconds com estado %d.\n", pid, delay, status);
    exit(0);
}


ARQUIVO sleep5.c

#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    printf(stdout, "Acordei!\n");
    return 0;
}


ARQUIVO sleep15.c

#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    printf(stdout, "Acordei!\n");
    return 0;
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o sleep5 sleep5.c
$gcc -Wall -o sleep15 sleep15.c
$gcc -Wall -o filhocidio filhocidio.c
$./filhocidio 10 ./sleep5
$./filhocidio 10 ./sleep15
-----------------------------------------------------

RESULTADO

indo dormir...
Acordei!
Child 8296 terminated within 10 seconds com estado 0.

----

indo dormir...
Program ./sleep15 exceeded limit of 10 seconds!
Child 8360 terminated within 10 seconds com estado 9.
-----------------------------------------------------

CONCLUSÃO 

Tanto os programas sleep5 e sleep 15 funcionam de forma semelhante: Assim que começam a rodar, 
printam uma mensagem, são pausados por uma determinada quantidade de segundos e printam mais  uma mensagem. 

O filhocidio inicia utilizando a função signal que cadastra uma reação ao recebimento do sinal do tipo SIGCHLD
que é emitido quando há a pausa, continuidade ou a morte de um filho antes do pai. A reação criada foi a função
childhandler que é chamada quando há o recebimento desse sinal. Nela, o pai recebe o status do processo pelo wait
e printa as informações do processo fiho. 

Voltando ao código, é criado um filho no fork. Foram usados 2 programas filhos: sleep5 e sleep 15 em que cada um
printa uma mensagem, "dorme" por 5 e 15 segundos respectivamente e depois printam outra mensagem.  

Enquanto o filho roda, o pai "dorme" por uma quantidade de segundos determinada por um parâmetro passado pela linha
de comando. Se o programa filho, que até então estava rodando em paralelo, não morrer antes que a "soneca" do pai
termine, ele printa a quantidade de tempo até então e mata o filho com o comando kill, e depois "dorme" novamente
apenas para que o sinal da morte do filho chegue e a função childhandler seja acionada, sendo que nesse print, o 
status do filho foi que ele terminou com código 9. Se o filho terminar antes do fim da "soneca" do pai, os dois prints
do filho são mostrados na tela e a childhandler é acionada, mostrando que o filho terminou com código 0 e o pai é encerrado.

-----------------------------------------------------

Questão 4) Multiplicação multi-processo
Faça um programa que:
Tenha um processo pai que abre dois blocos de memória compartilhada, m1 e m2;

Cria dois processos filho (use exec), P1 e P2: estes também fazem attach em m1
ou m2 respectivamente;

Cada um dá um sleep() randômico e escreve um valor int na área compartilhada dele,
e avisa o processo pai que um novo valor foi gerado, escrevendo tb um nr de sequencia;

O pai fica em loop verificando se houve um novo valor.Apenas quando ambos P1 e P2 geraram
um novo valor, o pai imprime o produto 
O pai fica em loop verificando se houve um novo valor.Apenas quando ambos P1 e P2 geraram
um novo valor, o pai imprime o produto dos valores gerados por P1 e P2.
-----------------------------------------------------
ARQUIVO ex4.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct bloco 
{
  int valor;
  int seq;
} bloco;

int main (int argc, char *argv[])
{
    int segmento1, segmento2, id, id2, pid, status;
    __key_t chave1 = 8751;
    __key_t chave2 = 8752;

    // aloca a memória compartilhada
    segmento1 = shmget (chave1, sizeof (bloco), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);

    // associa a memória compartilhada ao processo
    bloco* m1 = (bloco *) shmat (segmento1, 0, 0); // comparar o retorno com -1
    m1->valor = 0;
    m1->seq = 0;


    segmento2 = shmget (chave2, sizeof (bloco), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    bloco* m2 = (bloco *) shmat (segmento2, 0, 0);
    m2->valor = 0;
    m2->seq = 0;

    int valoresAntigos[] = {m1->seq, m2->seq};
    char* chaves[] = {"1", "2"};

    // PODE SER FEITO COM IF
    // Porém preferi fazer com for porque fica mais clean!
    printf("pid do pai = %d\n", getpid());
    for (int i = 0; i < 2; i++)
    {
        if ((id = fork()) == 0) // proccesso filho
        {
            printf("Executando arquivo auxiliar com filho %d de pid %d\n", i+1, getpid());
            execle("ex4aux", chaves[i], NULL, (char *)0);
        }
        else if (id < 0)
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
    }

    while((m1->seq == valoresAntigos[0])|(m2->seq == valoresAntigos[1]))
    {
        sleep(1);
        printf("Processo pai aguardando resultado!\n");
    }

    printf("Resultados:\nm1: %d\nm2: %d\n", m1->valor, m2->valor);


    // libera a memória compartilhada do processo
    shmdt (m1);
    shmdt (m2);

    // libera a memória compartilhada
    shmctl (segmento1, IPC_RMID, 0);
    shmctl (segmento2, IPC_RMID, 0);
    
    return 0;
}

-----------------------------------------------------

ARQUIVO ex4aux.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct bloco 
{
  int valor;
  int seq;
} bloco;

int main(int argc, char *argv[])
{
    int segmento;
    __key_t chave1 = 8751;
    __key_t chave2 = 8752;

    // adicionando randomização "verdadeira"
    time_t t;
    srand((unsigned) time(&t));

    if(strcmp(argv[0], "1"))
    {
        segmento = shmget (chave1, sizeof (bloco), S_IRUSR | S_IWUSR);
        bloco* p = (bloco *) shmat (segmento, 0, 0);

        sleep(rand() % 10 + 2);
        p->valor = rand() % 100 + 1;

        p->seq++;

        shmdt (p);

        printf("Processo de m1 finalizado!\n");
    }
    else if (strcmp(argv[0], "2"))
    {
        segmento = shmget (chave2, sizeof (bloco), S_IRUSR | S_IWUSR);
        bloco* p = (bloco *) shmat (segmento, 0, 0);

        int aux = rand();
        srand(aux); // mudando a seed de random, já que ambos processos são realizados ao mesmo tempo, então sempre tem o mesmo resultado
        sleep(rand() % 10 + 2);
        p->valor = rand() % 100 + 1;

        p->seq++;

        shmdt (p);
        printf("Processo de m2 finalizado!\n");
    }
    else
    {
        puts ("Erro ao adquirir a chave");
        exit (-2);
    }

    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO INSTANCIA 1
$gcc -Wall -o ex4 ex4.c
$gcc -Wall -o ex4aux ex4aux.c
$./ex4

-----------------------------------------------------
RESULTADO

pid do pai = 7410
Executando arquivo auxiliar com filho 1 de pid 7411
Executando arquivo auxiliar com filho 2 de pid 7412
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo de m1 finalizado!
Processo de m2 finalizado!
Processo pai aguardando resultado!
Resultados:
m1: 33
m2: 22

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO INSTANCIA 2
$gcc -Wall -o ex4 ex4.c
$gcc -Wall -o ex4aux ex4aux.c
$./ex4

-----------------------------------------------------
RESULTADO

pid do pai = 10273
Executando arquivo auxiliar com filho 1 de pid 10274
Executando arquivo auxiliar com filho 2 de pid 10275
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo de m1 finalizado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo pai aguardando resultado!
Processo de m2 finalizado!
Processo pai aguardando resultado!
Resultados:
m1: 5
m2: 100

-----------------------------------------------------
CONCLUSÃO

No programa "ex4.c" foi criado o struct bloco, que contém um valor e um 
número sequencial (ambos inteiros). Então foi alocado dois blocos 
de memória compartilhada m1 e m2, que cada um é do tamanho de um struct bloco. 
Após isso, é realizado um loop que cria dois processos filhos, nos 
quais os mesmos executam o programa "ex4aux.c", com o argumento 
"1" ou "2", dependendo de qual filho seja. Após isso há 
um while (do processo pai) que verifica se ambos os números 
sequencias de m1 e m2 foram alterados, e enquanto não forem printa 
no terminal "processo pai aguardando!", com intervalos (através de um sleep) 
de 1 segundo. Após ambos sequenciais serem alterados, é printado no terminal 
os valores de m1 e m2 (alterados pelo arquivo "ex4aux.c). Ao fim, 
é liberada toda memória dos blocos.

No programa "ex4aux.c", também foi criado o struct bloco. Após isso, 
é pego o tempo, e utiliza-se o mesmo como uma seed para a função
random, deixando a próxima de uma função randômica "verdadeira".
Após isso, há um if que verifica se o argumento foi "1" ou "2": 
Caso "1", há um sleep de 2 a 11 segundos, e então é colocado um inteiro 
aleatório (de 1 a 100) dentro do valor do bloco dentro de m1, 
e é incrementado 1 no sequencial do bloco m1. 
O mesmo ocorre no caso "2", porém no mesmo a seed do random é alterada 
pelo próprio random, pois caso ambos processos sejam realizados ao mesmo 
tempo, haverão valores iguais nos blocos m1 e m2. Após isso ambos os 
casos printam que foram finalizados e o programa retorna 0.