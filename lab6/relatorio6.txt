Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Faça um programa para criar dois processos que se comunicam via pipe. 
O Pai lê do pipe enquanto o filho escreve no pipe. Exiba o resultado do que foi 
escrito e lido.
-----------------------------------------------------
ARQUIVO ex1.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h> 

#define TAM_VETOR 100   

int main(void)
{
    int fd[2]; /* descritor a ser duplicado */
    int qtdLidos = 0;
    int qtdEnviados = 0;
    int id;

    if (pipe(fd) < 0)
    {
        puts ("Erro ao abrir os pipes");
        exit (-1);
    }

    id = fork();
    if(id == 0) //filho
    {
        close(fd[0]); //tem que fechar leitura
        char frase[TAM_VETOR] = "Ola pai! Aqui e o seu filho. Meu pid e ";
        char idStr [10];
        sprintf(idStr, "%d", getpid());
        strcat(frase, idStr);
        qtdEnviados = write(fd[1], frase, strlen(frase) + 1);
        printf("%d dados enviados\n", qtdEnviados);
        close(fd[1]);
    }
    else if (id > 0)
    {
        close(fd[1]); //tem que fechar escrita
        char frase[TAM_VETOR];

        qtdLidos = read(fd[0], frase, TAM_VETOR);
        printf("%d dados lidos: %s\n", qtdLidos, frase);
        printf("\nAqui e o pai e o pid do filho era %d\n", id);
        close(fd[0]);
    }
    else
    {
        puts ("Erro na criação do novo processo\n");
        exit (-2);
    }

    
    return 0;
}  

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex1 ex1.c
$./ex1
-----------------------------------------------------
RESULTADO

47 dados enviados
47 dados lidos: Ola pai! Aqui e o seu filho. Meu pid e 1346261

Aqui e o pai e o pid do filho era 1346261

-----------------------------------------------------
CONCLUSÃO

No programa pai, é criado um vetor de duas posições fd e nele são guardados os descritores 
de leitura e escrita respectivamente. Após isso, é feito o fork e um processo filho é criado. 
Na parte que apenas o processo filho roda, é fechada a comunicação de leitura com a função 
close e é enviado um dado, nesse caso uma string com tamanho de 47, pelo comando write pela
comunicação de pipe na segunda posição do vetor fd. No pai, é fechada a comunicação de saída
e é usado o comando read para ler o dado presente na pipe e colocar em alguma variável, um 
vetor de string no caso específico e depois a string foi printada. Foi necessário se atentar
à quantidade de bytes que se quer escrever ou ler nos comandos read ou write. Também se 
observa que, no write, foi usado o strlen(str) + 1 para dizer o quanto de bytes da capacidade
total da string que deveria ser enviada e, no read, por mais que ele pudesse ler até 100,
o read leu exatamente a quantidade de bytes que a string passada tem.

-----------------------------------------------------

Questão 2) Escreva um programa que primeiro criauma FIFO e em seguida cria dois processos
filho que escrevem uma string na FIFO.O pai dá um waitpid em seguida lê as strings desse 
FIFO e exibe na tela.
-----------------------------------------------------
ARQUIVO ex2.c

#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/wait.h>

#define FIFO "minhaFifo"
#define ROPENMODE (O_RDONLY | O_NONBLOCK)
#define WOPENMODE (O_WRONLY | O_NONBLOCK)

int main (void)
{
    int id = 0;
    char vPalavra[][10] = {"Linux", "Windows"};
    int status;
    int fifo;
    char vRetorno[2][10];
    char ch;
    int i = 0, j = 0;

    if (access(FIFO, F_OK) == -1)
    {
        if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
        {
            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
            return -1;
        }
        puts ("FIFO criada com sucesso");
    }  

    if ((fifo = open (FIFO, ROPENMODE)) < 0)
    {
        fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
        return -2;
    } 

    for (int i = 0; i < 2; i++)
    {
        id = fork();
        if(id == 0) //filho
        {
            if ((fifo = open(FIFO, WOPENMODE)) < 0)
            {
                puts ("Erro ao abrir a FIFO para escrita"); 
                return -1;
            }
            printf("palavra[%d]: %s --- %ld\n", i, vPalavra[i], strlen(vPalavra[i]) + 1);
            write(fifo, vPalavra[i],strlen(vPalavra[i]) + 1);
            close (fifo);
            exit(0);
        }
        if(id < 0)
        {
            puts ("Erro ao abrir os pipes");
            exit (-1);
        }

    }

    waitpid(-1, &status, 0);

    while (read (fifo, &ch, sizeof(ch)) > 0)
    {
        vRetorno[i][j++] = ch;

        if (ch == '\0')
        {
            i++;
            j = 0;
        }
    }

    close(fifo);

    printf("Palavras lidas: %s e %s\n", vRetorno[0], vRetorno[1]);
    return 0;
} 

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex2 ex2.c
$./ex2

-----------------------------------------------------
RESULTADO

FIFO criada com sucesso
palavra[0]: Linux --- 6
palavra[1]: Windows --- 8
Palavras lidas: Linux e Windows

-----------------------------------------------------

CONCLUSÃO

No código é utilizado a função mkfifo para criar uma fifo apenas quando ela não existe, sendo essa 
verificação feita com o comando access. É aberta a fifa no modo de leitura e depois os filhos são 
criados e em cada filho a fifa é aberta no modo de escrita de modo que, com a função write, ele escreve
a string na fifo de modo semelhante a um arquivo. Enquanto os filhos terminam de processar, o pai os 
espera com um waitpid e lê da pid caracter por caracter e os copia para um array de strings. No final,
as strings formadas foram printadas mostrando que o pai leu corretamente as strings da fifo. Tanto nos 
filhos quano no pai a fifo foi fechada antes do processo ser encerrado. 

-----------------------------------------------------

Questão 3) Faça um programa para criar um pipe e
executar dois processos que são utilitários do Unix
que se comuniquem através do pipe criado, assim
como a shell faz. Exemplo: 

endler$ ps | wc
 28 28 310

-----------------------------------------------------
ARQUIVO ex3.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h> 

int main(void)
{
    int fd[2]; /* descritor a ser duplicado */
    int id;

    if (pipe(fd) < 0)
    {
        puts ("Erro ao abrir os pipes");
        exit (-1);
    }

    id = fork();
    if(id == 0) //filho
    {
        close(fd[0]); //tem que fechar leitura
        
        dup2(fd[1], 1);
        system("ps");

        close(fd[1]);
    }
    else if (id > 0)
    {
        close(fd[1]); //tem que fechar escrita

        dup2(fd[0], 0);
        system("wc");
        close(fd[0]);
    }
    else
    {
        puts ("Erro na criação do novo processo\n");
        exit (-2);
    }

    return 0;
} 
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex3 ex3.c
$./ex3
-----------------------------------------------------

RESULTADO

    7      28     209

-----------------------------------------------------

CONCLUSÃO 


No programa, após a criação dos canais de comunicação e da criação do processo filho pelo 
fork, no filho o canal de leitura é fechado e o stdout é redirecionado para a o canal de 
comunicação de escrita fd[1]. Com isso, ao usar o system("ps"), a saída desse comando vai para 
o pipe. No programa pai, o canal de leitura é fechado e o stdin é redirecionado para o canal 
de leitura fd[0]. Com isso, utilizando a entrada que já estava com o resultado do comando anterior,
o comando system("wc") atua em cima do que já estava na saída, assim como o comando na shell e 
printa a saída no terminal. Em ambos os casos, as saídas não utilizadas anteriormente foram fechadas.

-----------------------------------------------------

Questão 4) Faça um programa que cria dois processos
leitores e um processo escritor em uma mesma
pipe. Faça o escritor dormir metade do tempo
dos leitores, e mostre como os leitores
consomem os dados produzidos pelo escritor.
Obs: não force uma alternância controlada por
SIGSTOP/SIGCONT.
-----------------------------------------------------
ARQUIVO ex4.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

int main (int argc, char *argv[])
{
    int nDadosTx, nDadosRx; // quantidade de dados transmitidos/recebidos
    int fd[2]; // descritor dos pipes
    const char textoTX[] = "mensagem";
    char textoRX[sizeof textoTX];
    int pid1, pid2, status;

    if (pipe(fd) < 0)
    {
        puts ("Erro ao abrir os pipes");
        exit (-1);
    }

    if((pid1 = fork()) == 0) // filho 1 (leitor)
    {
        sleep(4);
        close(fd[1]);
        nDadosRx = read(fd[0], textoRX, sizeof textoRX);
        printf("Leitura de %d dados pelo filho 1.\nConteúdo: %s\n", nDadosRx, textoRX);
        close(fd[0]);
        exit(3);
    }
    if ((pid2 = fork()) == 0) // filho 2 (leitor)
    {
        sleep(4);
        close(fd[1]);
        nDadosRx = read(fd[0], textoRX, sizeof textoRX);
        printf("Leitura de %d dados pelo filho 2.\nConteúdo: %s\n", nDadosRx, textoRX);
        close(fd[0]);
        exit(3);
    }

    sleep(2);
    close(fd[0]);
    nDadosTx = write(fd[1], textoTX, strlen(textoTX) + 1);
    close(fd[1]);
    printf("%d dados escritos pelo pai!\n", nDadosTx);

    waitpid(-1, &status, 0);

    
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex4 ex4.c
$./ex4

-----------------------------------------------------
RESULTADO 1 (sleep 1 no pai e sleep 2 nos filhos)

9 dados escritos pelo pai!
Leitura de 0 dados pelo filho 1.
Leitura de 9 dados pelo filho 2.
Conteúdo: 
Conteúdo: mensagem

------------------------------------------------------
RESULTADO 2 (sleep 2 no pai e sleep 4 nos filhos)

9 dados escritos pelo pai!
Leitura de 9 dados pelo filho 1.
Conteúdo: mensagem
Leitura de 0 dados pelo filho 2.
Conteúdo: 

-----------------------------------------------------
CONCLUSÃO

A partir do resultado, é possível concluir que após a leitura da pipe,
não é possível reler o que já foi lido, pois o dado é removido da
pipe pelo processo que o leu.