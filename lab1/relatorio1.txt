Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Faça um programa para criar dois processos, o pai escreve seu pid e espera o
filho terminar e o filho escreve o seu pid e termina.
-----------------------------------------------------
ARQUIVO ex1.c

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int  pid, status;
    pid = fork();
    if (pid!=0)
    { //Pai
        printf("Pai, Pid proprio: %d e Pid do filho: %d\n", getpid(), pid);
        waitpid(-1, &status, 0);
    }else 
    { //Filho
        printf("Filho,  Pid: %d\n", getpid());
        printf("Programa terminado!\n");
        exit(3);
    }
    return 0;
}
-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex1 ex1.c
$./ex1
-----------------------------------------------------
RESULTADO

Pai, Pid proprio: 36422 e Pid do filho: 36423
Filho,  Pid: 36423
Programa terminado!
-----------------------------------------------------
CONCLUSÃO

No programa, foi criada a variável pid que é reponsável por guardar o pid do processo
filho que o fork() (programa que faz cópia do processo atual e gera um processo filho). 
Com isso, há um if e else que, se o pid for igual a 0, é porque ele é filho, enquanto se for
diferente, é o pai. Isso acontece porque como o pid é o processo filho, o próprio processo filho
não criou outro, então o valor do pid nesse caso é zero. Já no pai não é zero justamene por que 
consegiu criar perfeitamente o filho. Com isso, ele entra primeiramente no caso em que é o pai, printa o pid 
do filho e o próprio e depois espera o processo do filho terminar. no processo do filho, ele entra no caso do
else, que printa o próprio pid e o número printado é exatamente o mesmo visualizado no print anterior. Após
terminar de executar, ele volta para o pai e o programa acaba. 
-----------------------------------------------------

Questão 2) Agora, usando a mesma estrutura de processos pai e filho, declare uma
variável visível ao pai e ao filho, no pai inicialize a variável com1 e imprima seu
valor antes do fork(). No filho, altere o valor da variável para 5 e imprima o seu
valor antes do exit(). Agora, no pai, imprima novamente o valor da variável após o
filho ter alterado a variável - após a waitpid(). Justifique os resultados obtidos.
-----------------------------------------------------
ARQUIVO ex2.c

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int  pid, status;
    int var = 1;
    printf("Variavel: %d\n", var);
    pid = fork();
    if (pid!=0)
    { //Pai
        waitpid(-1, &status, 0);
        printf("Pai: Variavel: %d\n", var);

    }else 
    { //Filho
        var = 5;
        printf("Filho: Variavel: %d\n", var);

        printf("Programa terminado!\n");
        exit(3);
    }
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex2 ex2.c
$./ex2
-----------------------------------------------------
RESULTADO
Variavel: 1
Filho: Variavel: 5
Programa terminado!
Pai: Variavel: 1
-----------------------------------------------------
CONCLUSÃO

Não houve mudança na variável do processo do pai, ocorrendo apenas na variável do processo do filho. Isso
faz refletir que as variáveis, por mais que sejam do mesmo tipo e tenham o mesmo nome, não são realmente as
mesmas, ou seja, processos diferentes, mesmo que pais, filhos, netos... não compartilham a mesma stack e,
portanto, as mesmas variáveis.
-----------------------------------------------------

Questão 3) Use o programa anterior para ler e ordenar um vetor de 10 posições. O filho
ordena o vetor e o pai exibe os dados do vetor antes do fork() e depois do
waitpid(). Eles usarão o mesmo vetor na memória? Justifique.
-----------------------------------------------------
ARQUIVO ex3.c

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

void exibe(int v[])
{
    printf("Vetor: {");
    for(int i = 0; i < 10; i++)
    {
        printf("%d, ", v[i]);
    }
    printf("}\n");
}

void quicksort(int num, int *vetor) 
{
    if (num <= 1)
        return;
    else 
    {
        int x = vetor[0];
        int a = 1;
        int b = num - 1;
        do 
        {
            while (a < num && vetor[a] <= x)
                a++;
            while (vetor[b] > x)
                b--;
            if (a < b) {
                int aux = vetor[a];
                vetor[a] = vetor[b];
                vetor[b] = aux;
                a++;
                b--;
            }
        } while (a <= b);

        vetor[0] = vetor[b];
        vetor[b] = x;
        
        quicksort(b, vetor);
        quicksort(num - a, &vetor[a]);
    }
}

int main(void)
{
    int  pid, status;
    int vec[] = {7, 8, 9, 0, 4, 5, 6, 1 ,2 ,3};
    exibe(vec);
    pid = fork();
    if (pid!=0)
    { //Pai
        waitpid(-1, &status, 0);
        exibe(vec);
    }else 
    { //Filho
        printf("Filho: ");
        quicksort(10, vec);
        exibe(vec);
        printf("Programa terminado!\n");
        exit(3);
    }
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o ex3 ex3.c
$./ex3
-----------------------------------------------------
RESULTADO

Vetor: {7, 8, 9, 0, 4, 5, 6, 1, 2, 3, }
Filho: Vetor: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, }
Programa terminado!
Vetor: {7, 8, 9, 0, 4, 5, 6, 1, 2, 3, }
-----------------------------------------------------

CONCLUSÃO 


Não, pois cada processo tem a sua própria stack, ou seja, um variável salva na stack de um
processo não pode ser utilizada por outro processo. Foi perceptível pois no processo do filho,
mesmo ordenando o vetor nesse processo, o vetor no pai não foi alterado, o que mostra que mesmo
as variáveis tendo o mesmo valor e nome, elas são diferentes por estarem em stacks diferentes.
-----------------------------------------------------

Questão 4) Modifique o programa anterior para que o filho execute um programa elaborado
por você, que mande imprimir uma mensagem qualquer no vídeo, por exemplo,
“alo mundo”. Em seguida altere o programa do item 4 para o filho executar o
programa echo da shell.
-----------------------------------------------------
ARQUIVO hello.c

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf("hello,  Pid: %d, Pid do pai: %d\n", getpid(), getppid());
    printf("Alo mundo!\n");
    return 0;
}

-----------------------------------------------------

ARQUIVO ex4_1.c

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int  pid, status;
    pid = fork();
    if (pid!=0)
    { //Pai
        printf("Pai, Pid proprio: %d e Pid do filho: %d\n", getpid(), pid);
        if (waitpid(pid, &status, 0) == pid)
        {
            printf("Programa terminado com retorno em 0!\n");
        }
    }else 
    { //Filho
        printf("Filho,  Pid: %d, Pid do pai: %d\n", getpid(), getppid());
        execle("hello", "hello", NULL, (char *)0);
        printf("Programa terminado!\n");
        exit(3);
    }
    return 0;
}

-----------------------------------------------------

ARQUIVO ex4_2.c

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int  pid, status;
    pid = fork();
    if (pid!=0)
    { //Pai
        if (waitpid(pid, &status, 0) == pid)
        {
            printf("Programa terminado com retorno em 0!\n");
        }
    }else 
    { //Filho
        system("echo Alo mundo!");
        printf("Programa terminado!\n");
        exit(3);
    }
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o hello hello.c
$gcc -Wall -o ex41 ex4_1.c
$./ex41

-----------------------------------------------------
RESULTADO

Pai, Pid proprio: 865986 e Pid do filho: 865987
Filho,  Pid: 865987, Pid do pai: 865986
hello,  Pid: 865987, Pid do pai: 865986
Alo mundo!
Programa terminado com retorno em 0!

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 2
$gcc -Wall -o ex42 ex4_2.c
$./ex42

-----------------------------------------------------
RESULTADO

Alo mundo!
Programa terminado!
Programa terminado com retorno em 0!
-----------------------------------------------------
CONCLUSÃO

Na parte 1, após fazer o fork e o processo pai começar a esperar o filho terminar de rodar, o processo filho utiliza o comando execle
para iniciar o processo que inicia com a execução do executável hello oriundo da compilação do programa hello.c . Com isso, o programa 
executa os comandos presentes no código de hello.c e, após terminar, volta para o processo pai. Com isso, foi perceptível que o comando
execle substitui o processo filho pelo que é passado para ele, com o novo virando o próprio filho original e por isso, ele retorna para
o pai, e não para o resto da execução do antigo filho, o que está de acordo com o manual da função execle: "The  exec()  family  of  
functions replaces the current process image with a new process image.". 

Na parte 2, após fazer o fork e o pai começar a esperar o filho terminar de rodar, o processo filho, utilizando o comando system(), ele
executa o echo para que ele printe alguma coisa no terminal e depois continua a executar normalmente o processo do filho e depois volta
para o pai. Com isso, foi perceptível que não houve substituição de processos, e sim a criação de um processo filho que printa na shell
e retornou normalmente para o comando que o executou, que é o filho original.






