Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Execute o programa dado (exemplo de uso
de semáforos) e explique sua execução. 

-----------------------------------------------------
ARQUIVO semaforo.c

/* Exemplo de uso de unico semáforo*/
#include <sys/sem.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main (int argc, char * argv[])
{
    int i;
    char letra = 'o';
    int semId;
    printf("Qtd argc: %d\n", argc);
    if (argc > 1)
    {
        semId = semget (8752, 1, 0666 | IPC_CREAT);
        setSemValue(semId);
        letra = 'x';
        sleep (2);
    }
    else
    {
        while ((semId = semget (8752, 1, 0666)) < 0)
        {
            putchar ('.'); fflush(stdout);
            sleep (1);
        }
    }
    for (i=0; i<10; i++)
    {
        semaforoP(semId);
        putchar (toupper(letra)); fflush(stdout);
        sleep (rand() %3);
        putchar (letra); fflush(stdout);
        semaforoV(semId);
        sleep (rand() %2);
    }
        printf ("\nProcesso %d terminou\n", getpid());
    if (argc > 1)
    {
        sleep(10);
        delSemValue(semId);
    }
    return 0;
}
int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO 1
$gcc -Wall -o semaforo semaforo.c 
$./semaforo
-----------------------------------------------------
RESULTADO 1

Qtd argc: 1
OoOoOoOoOoOoOoOoOoOo
Processo 8262 terminou
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO 2
$gcc -Wall -o semaforo semaforo.c 
$./semaforo 1

-----------------------------------------------------
RESULTADO 2


-----------------------------------------------------
CONCLUSÃO

Na primeira execução em que não é passado nenhum argumento para a main, enquanto o semáforo não 
é criado, é printado um ponto. Após a criação, por 10 vezes, o programa entra na região crítica
com a função semaforoP que decrementa o valor do semaforo, coloca o caractere "o" em letra maiúscula, 
dorme, coloca a letra "o" e incrementa o valor do semáforo com a função "semaforoV" e dorme. Assim, 
Isso garante que apenas quem entrou na região crítica está realizando as operações no momento sem deixar
que outro processo que poderia estar querendo usar esse código no momento possa utilizar e fique esperando.

Na segunda execução em que é passado

-----------------------------------------------------

Questão 2) 
Usando mutex, modifique o programa Corrida de Sampo
para que o problema identificado anteriormente não ocorra.
-----------------------------------------------------
ARQUIVO corrida_com_mutex.c

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#define NUM_THREADS 5
#define PULO_MAXIMO 100
#define DESCANSO_MAXIMO 1
#define DISTANCIA_PARA_CORRER 100
static int classificacao = 1;
static pthread_mutex_t lock;
static char * resp[200];
static int cont = 0;

void *Correr(void *sapo)
{
    int pulos = 0;
    int distanciaJaCorrida = 0;
    while (distanciaJaCorrida <= DISTANCIA_PARA_CORRER) 
    {
        int pulo = rand() % PULO_MAXIMO;
        distanciaJaCorrida += pulo;
        pulos++;
        printf("Sapo %d pulou\n", (int) sapo);
        int descanso = rand() % DESCANSO_MAXIMO;
        sleep(descanso);
    }
    pthread_mutex_lock( &lock); 
    printf("Sapo %d chegou na posicaoo %d com %d pulos\n", (int) sapo, classificacao, pulos);
    cont++;
    pthread_mutex_unlock( &lock );
    classificacao++;
    pthread_exit(NULL);
}

int main()
{
    classificacao =1;
    pthread_t threads[NUM_THREADS];
    int t;
    printf("Corrida iniciada ... \n");
    for(t=0;t < NUM_THREADS;t++) pthread_create(&threads[t], NULL, Correr, (void *) t);
    for(t=0;t < NUM_THREADS; t++) pthread_join(threads[t],NULL);
    printf("\n Acabou!!\n");
    pthread_exit(NULL);

}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o corrida corrida_com_mutex.c -lpthread
$./corrida 

-----------------------------------------------------
RESULTADO 1

Corrida iniciada ... 
Sapo 0 pulou
Sapo 1 pulou
Sapo 2 pulou
Sapo 1 pulou
Sapo 2 pulou
Sapo 0 pulou
Sapo 4 pulou
Sapo 1 chegou na posicaoo 1 com 2 pulos
Sapo 3 pulou
Sapo 2 chegou na posicaoo 2 com 2 pulos
Sapo 4 pulou
Sapo 3 pulou
Sapo 0 chegou na posicaoo 3 com 2 pulos
Sapo 4 chegou na posicaoo 4 com 2 pulos
Sapo 3 chegou na posicaoo 5 com 2 pulos

RESULTADO 2

Corrida iniciada ... 
Sapo 0 pulou
Sapo 2 pulou
Sapo 1 pulou
Sapo 0 pulou
Sapo 4 pulou
Sapo 3 pulou
Sapo 2 pulou
Sapo 4 pulou
Sapo 1 pulou
Sapo 0 chegou na posicaoo 1 com 2 pulos
Sapo 3 pulou
Sapo 2 chegou na posicaoo 2 com 2 pulos
Sapo 4 chegou na posicaoo 3 com 2 pulos
Sapo 1 pulou
Sapo 3 chegou na posicaoo 4 com 2 pulos
Sapo 1 pulou
Sapo 1 chegou na posicaoo 5 com 4 pulos

-----------------------------------------------------

CONCLUSÃO

Para evitar empates falsos, foi utilizado um mutex em que a variável contadora
foi a lock. Foram chamadas as funções que garantem a exclusão mútua pthread_mutex_lock()
e pthread_mutex_unlock() respectivamente acima e abaixo das seguintes linhas de código:

printf("Sapo %d chegou na posicaoo %d com %d pulos\n", (int) sapo, classificacao, pulos);
cont++;

Foram escolhidas essas linhas para serem englobada pela exclusão múltipla pois, assim que uma 
thread entra na execução dessas linhas, as outras pausam. Então a que está executando consegue, 
sem problemas, fazer o print e incrementar o cont de modo que a próxima que entrar nessa parte 
já estará com a contagem certinha, não pode atropelar esse processo.

-----------------------------------------------------

Questão 3) Faça programas para alterar um valor de uma variável na memória compartilhada.
Um programa soma 1 à variável e o outro soma 5 à variável. Utilize semáforos para alterar a 
variável (região crítica).
-----------------------------------------------------
ARQUIVO main.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main(void)
{
    __key_t chave1 = 8751;
    __key_t chave2 = 8753;
    int vPids[2];


    int segmento = shmget (chave1, sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(segmento < 0) {
        perror("shmget");
        exit(1);
    }
    int* p = (int *) shmat (segmento, 0, 0);

    int semId = semget (chave2, 1, 0666 | IPC_CREAT);
    printf("SemID: %d\n", semId);
    int id, status;
    setSemValue(semId);
    for (int i = 0; i < 2; i++)
    {
        printf("i: %d\n", i);
        vPids[i] = fork();
        if (vPids[i] == 0) //processo filho
        {   
            printf("id do filho: %d\n", getpid());
            execl("aux1", "aux1", NULL, (char *)0);
        }
        else if( vPids[i] < 0 )
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
    }
    waitpid(vPids[0], &status, 0);
    waitpid(vPids[1], &status, 0);
    printf("Processo pai %d terminou\n", getpid());
    delSemValue(semId);
    shmdt (p);
    shmctl (segmento, IPC_RMID, 0);
    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
-----------------------------------------------------

ARQUIVO ex1.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main(void)
{
    __key_t chave1 = 8751;
    __key_t chave2 = 8753;
    int vPids[2];


    int segmento = shmget (chave1, sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(segmento < 0) {
        perror("shmget");
        exit(1);
    }
    int* p = (int *) shmat (segmento, 0, 0);

    int semId = semget (chave2, 1, 0666 | IPC_CREAT);
    printf("SemID: %d\n", semId);
    int id, status;
    setSemValue(semId);
    for (int i = 0; i < 2; i++)
    {
        printf("i: %d\n", i);
        vPids[i] = fork();
        if (vPids[i] == 0) //processo filho
        {   
            printf("id do filho: %d\n", getpid());
            execl("aux1", "aux1", NULL, (char *)0);
        }
        else if( vPids[i] < 0 )
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
    }
    waitpid(vPids[0], &status, 0);
    waitpid(vPids[1], &status, 0);
    printf("Processo pai %d terminou\n", getpid());
    delSemValue(semId);
    shmdt (p);
    shmctl (segmento, IPC_RMID, 0);
    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

-----------------------------------------------------

ARQUIVO ex2.C

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main(void)
{
    printf("Aux2 - Entrei no filho %d\n", getpid());
    __key_t chave1 = 8751;
    __key_t chave2 = 8753;


    int segmento = shmget (chave1, sizeof(int), S_IRUSR | S_IWUSR);
    if(segmento < 0) {
        perror("shmget");
        exit(1);
    }
    int* p = (int *) shmat (segmento, 0, 0);

    int semId = semget (chave2, 1, 0666 | IPC_CREAT);
    printf("SemID: %d\n", semId);
    for(int i = 0; i < 10; i++) {
        semaforoP(semId);
        (*p) +=5;
        printf("Valor atual: %d --- filho: %d\n", *p, getpid());
        semaforoV(semId);
        sleep(1);
    }
    shmdt (p);
    shmctl (segmento, IPC_RMID, 0);
    printf ("\nProcesso %d terminou\n", getpid());
    exit(0);
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o aux1 aux1.c
$gcc -Wall -o main main.c 
$./main 
-----------------------------------------------------

RESULTADO

SemID: 22
i: 0
i: 1
id do filho: 18915
id do filho: 18916
Aux1 - Entrei no filho 18915
SemID: 22
Valor atual: 1 --- filho: 18915
Aux2 - Entrei no filho 18916
SemID: 22
Valor atual: 6 --- filho: 18916
Valor atual: 7 --- filho: 18915
Valor atual: 12 --- filho: 18916
Valor atual: 13 --- filho: 18915
Valor atual: 18 --- filho: 18916
Valor atual: 19 --- filho: 18915
Valor atual: 24 --- filho: 18916
Valor atual: 29 --- filho: 18916
Valor atual: 30 --- filho: 18915
Valor atual: 35 --- filho: 18916
Valor atual: 36 --- filho: 18915
Valor atual: 41 --- filho: 18916
Valor atual: 42 --- filho: 18915
Valor atual: 47 --- filho: 18916
Valor atual: 48 --- filho: 18915
Valor atual: 53 --- filho: 18916
Valor atual: 54 --- filho: 18915
Valor atual: 59 --- filho: 18916
Valor atual: 60 --- filho: 18915

Processo 18916 terminou

Processo 18915 terminou
Processo pai 18914 terminou
-----------------------------------------------------

CONCLUSÃO 

Na main, é criado o semáforo e a memória compartilhada com chaves fixas de modo que outros 
processos podem anexar em seus programas esse sinal e memória. Depois, são criados dois filhos que 
são transformados pelo execl para seus respectivos executáveis (exec1 e exec2). Com isso, cada um 
percorre um loop com 10 iterações para fazer seu respctivo acréscimo na variável compartilhada. 
Entretanto, para que n

-----------------------------------------------------