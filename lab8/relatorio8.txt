Bento Bruno Contarini Gonçalves  -  2311122
Mayara Ramos Damazio - 2210833

Questão 1) Execute o programa dado (exemplo de uso
de semáforos) e explique sua execução. 

-----------------------------------------------------
ARQUIVO semaforo.c

/* Exemplo de uso de unico semáforo*/
#include <sys/sem.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main (int argc, char * argv[])
{
    int i;
    char letra = 'o';
    int semId;
    printf("Qtd argc: %d\n", argc);
    if (argc > 1)
    {
        semId = semget (8752, 1, 0666 | IPC_CREAT);
        setSemValue(semId);
        letra = 'x';
        sleep (2);
    }
    else
    {
        while ((semId = semget (8752, 1, 0666)) < 0)
        {
            putchar ('.'); fflush(stdout);
            sleep (1);
        }
    }
    for (i=0; i<10; i++)
    {
        semaforoP(semId);
        putchar (toupper(letra)); fflush(stdout);
        sleep (rand() %3);
        putchar (letra); fflush(stdout);
        semaforoV(semId);
        sleep (rand() %2);
    }
        printf ("\nProcesso %d terminou\n", getpid());
    if (argc > 1)
    {
        sleep(10);
        delSemValue(semId);
    }
    return 0;
}
int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO 1
$gcc -Wall -o semaforo semaforo.c 
$./semaforo
-----------------------------------------------------
RESULTADO 1

Qtd argc: 1
OoOoOoOoOoOoOoOoOoOo
Processo 8262 terminou
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO 2
$gcc -Wall -o semaforo semaforo.c 
$./semaforo 1

-----------------------------------------------------
RESULTADO 2


-----------------------------------------------------
CONCLUSÃO

Na primeira execução em que não é passado nenhum argumento para a main, enquanto o semáforo não 
é criado, é printado um ponto. Após a criação, por 10 vezes, o programa entra na região crítica
com a função semaforoP que decrementa o valor do semaforo, coloca o caractere "o" em letra maiúscula, 
dorme, coloca a letra "o" e incrementa o valor do semáforo com a função "semaforoV" e dorme. Assim, 
Isso garante que apenas quem entrou na região crítica está realizando as operações no momento sem deixar
que outro processo que poderia estar querendo usar esse código no momento possa utilizar e fique esperando.

Na segunda execução em que é passado

-----------------------------------------------------

Questão 2) 
Produtor-Consumidor
l Escreva um programa formado por dois
processos concorrentes, leitor e impressor, que
usam memória compartilhada executando um
loop infinito. Para sincronizar as suas ações, eles
fazem uso de semáforos.
l O processo leitor fica lendo caracteres da entrada
padrão e colocando em um buffer de 16 posições.
Quando o buffer está cheio o processo impressor
deve imprimi-lo na saída padrão.
-----------------------------------------------------
ARQUIVO corrida_com_mutex.c

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/sem.h>

#define BUFFER_SIZE 16
#define TRUE 1
#define false 0

// cores para output
#define RED  "\x1b[31m"
#define GREEN  "\x1b[32m"
#define YELLOW  "\x1b[33m"
#define BLUE  "\x1b[34m"
#define RESET   "\x1b[0m"

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

// inicializa o valor do semáforo
int setSemValue(int vecSemId, int semId, int value);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int vecSemId, int semId);
// operação V
int semaforoV(int vecSemId, int semId);

void zeraBuffer(char* buffer);

int main(void)
{
    int segmento, id, vecSemId;
    int semPro = 0;
    int semImp = 1;
    char* buffer;

    segmento = shmget(IPC_PRIVATE, sizeof(char) * BUFFER_SIZE , IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);

    buffer = (char *)shmat(segmento, 0, 0);
    zeraBuffer(buffer);

    vecSemId = semget(8751, 2, 0666 | IPC_CREAT);
    if (vecSemId == -1)
    {
        puts( "Erro na criação do  semáforo!");
        exit(-1);
    }
    
    setSemValue(vecSemId, semPro, 1);
    setSemValue(vecSemId, semImp, 0);

    if ((id = fork()) < 0)
    {
        puts( "Erro na criação do novo processo!");
        exit(-2);
    }
    else if (id == 0) // processo filho - produtor
    {
        char c;
        while(TRUE)
        {
            semaforoP(vecSemId, semPro);
            for(int i = 0; i < BUFFER_SIZE; i++)
            {
                printf(BLUE"leitor -"RESET" Insira um caracter (apenas um!!!) na posição " GREEN"%d"RESET":\n", i);
                c = getchar();
                while(getchar() != '\n'); // consome lixo (e o enter) após o caracter!
                buffer[i] = c;
            }
            semaforoV(vecSemId, semImp);
        }
    }
    else //              processo pai - impressor
    {
        while(TRUE)
        {
            semaforoP(vecSemId, semImp);

            printf(YELLOW"impressor -"RESET" Entrou em execução...\n");
            printf(YELLOW"impressor -"RESET" Conteúdo do buffer : "GREEN"["RESET);


            for(int i = 0; i < BUFFER_SIZE; i++)
            {
                printf(GREEN"%c"RESET, buffer[i]);
                if (i < BUFFER_SIZE-1) printf(", ");
            }
            printf(GREEN"]\n"RESET);

            zeraBuffer(buffer);

            semaforoV(vecSemId, semPro);
        }
    }

    return 0;
}

void zeraBuffer(char* buffer)
{
    for(int i = 0; i < BUFFER_SIZE; i++ )
    {
        buffer[i] = '\0';
    }
}

int setSemValue(int vecSemId, int semId, int value)
{
    union semun semUnion;
    semUnion.val = value;
    return semctl(vecSemId, semId, SETVAL, semUnion);
}

void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}

int semaforoP(int vecSemId, int semId)
{
    struct sembuf semB;
    semB.sem_num = semId;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(vecSemId, &semB, 1);
    return 0;
}

int semaforoV(int vecSemId, int semId)
{
    struct sembuf semB;
    semB.sem_num = semId;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(vecSemId, &semB, 1);
    return 0;
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO PARTE 1
$gcc -Wall -o ex2 ex2.c
$./ex2

-----------------------------------------------------
RESULTADO 1

leitor - Insira um caracter (apenas um!!!) na posição 0:
0
leitor - Insira um caracter (apenas um!!!) na posição 1:
1
leitor - Insira um caracter (apenas um!!!) na posição 2:
2
leitor - Insira um caracter (apenas um!!!) na posição 3:
3
leitor - Insira um caracter (apenas um!!!) na posição 4:
4
leitor - Insira um caracter (apenas um!!!) na posição 5:
5
leitor - Insira um caracter (apenas um!!!) na posição 6:
6
leitor - Insira um caracter (apenas um!!!) na posição 7:
7
leitor - Insira um caracter (apenas um!!!) na posição 8:
8
leitor - Insira um caracter (apenas um!!!) na posição 9:
9
leitor - Insira um caracter (apenas um!!!) na posição 10:
a
leitor - Insira um caracter (apenas um!!!) na posição 11:
b
leitor - Insira um caracter (apenas um!!!) na posição 12:
c
leitor - Insira um caracter (apenas um!!!) na posição 13:
d
leitor - Insira um caracter (apenas um!!!) na posição 14:
e
leitor - Insira um caracter (apenas um!!!) na posição 15:
f
impressor - Entrou em execução...
impressor - Conteúdo do buffer : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f]
-----------------------------------------------------

CONCLUSÃO

O programa funciona como o esperado.
Para a realização do programa foram criados dois semáforos: o semPro (semáforo do produtor) e o 
semImp (semáforo do impressor). Essa criação foi feita num vetor de semáforos vecSemId.
Na entrada de cada zona crítica (execução do processo) é feita a operação P (down) no semáforo 
do processo em que se encontra, e no final da execução do processo é feita a operação V (up)
do outro processo. 
Dessa forma, cria-se uma zona crítica segura, sem a possibilidade do produtor
acessar a memória compartilhada ao mesmo tempo do impressor.

-----------------------------------------------------

Questão 3) Faça programas para alterar um valor de uma variável na memória compartilhada.
Um programa soma 1 à variável e o outro soma 5 à variável. Utilize semáforos para alterar a 
variável (região crítica).
-----------------------------------------------------
ARQUIVO main.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main(void)
{
    __key_t chave1 = 8751;
    __key_t chave2 = 8753;
    int vPids[2];


    int segmento = shmget (chave1, sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(segmento < 0) {
        perror("shmget");
        exit(1);
    }
    int* p = (int *) shmat (segmento, 0, 0);

    int semId = semget (chave2, 1, 0666 | IPC_CREAT);
    printf("SemID: %d\n", semId);
    int id, status;
    setSemValue(semId);
    for (int i = 0; i < 2; i++)
    {
        printf("i: %d\n", i);
        vPids[i] = fork();
        if (vPids[i] == 0) //processo filho
        {   
            printf("id do filho: %d\n", getpid());
            execl("aux1", "aux1", NULL, (char *)0);
        }
        else if( vPids[i] < 0 )
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
    }
    waitpid(vPids[0], &status, 0);
    waitpid(vPids[1], &status, 0);
    printf("Processo pai %d terminou\n", getpid());
    delSemValue(semId);
    shmdt (p);
    shmctl (segmento, IPC_RMID, 0);
    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
-----------------------------------------------------

ARQUIVO ex1.c

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main(void)
{
    __key_t chave1 = 8751;
    __key_t chave2 = 8753;
    int vPids[2];


    int segmento = shmget (chave1, sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(segmento < 0) {
        perror("shmget");
        exit(1);
    }
    int* p = (int *) shmat (segmento, 0, 0);

    int semId = semget (chave2, 1, 0666 | IPC_CREAT);
    printf("SemID: %d\n", semId);
    int id, status;
    setSemValue(semId);
    for (int i = 0; i < 2; i++)
    {
        printf("i: %d\n", i);
        vPids[i] = fork();
        if (vPids[i] == 0) //processo filho
        {   
            printf("id do filho: %d\n", getpid());
            execl("aux1", "aux1", NULL, (char *)0);
        }
        else if( vPids[i] < 0 )
        {
            puts ("Erro na criação do novo processo");
            exit (-2);
        }
    }
    waitpid(vPids[0], &status, 0);
    waitpid(vPids[1], &status, 0);
    printf("Processo pai %d terminou\n", getpid());
    delSemValue(semId);
    shmdt (p);
    shmctl (segmento, IPC_RMID, 0);
    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

-----------------------------------------------------

ARQUIVO ex2.C

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
//operação V
int semaforoV(int semId);

int main(void)
{
    printf("Aux2 - Entrei no filho %d\n", getpid());
    __key_t chave1 = 8751;
    __key_t chave2 = 8753;


    int segmento = shmget (chave1, sizeof(int), S_IRUSR | S_IWUSR);
    if(segmento < 0) {
        perror("shmget");
        exit(1);
    }
    int* p = (int *) shmat (segmento, 0, 0);

    int semId = semget (chave2, 1, 0666 | IPC_CREAT);
    printf("SemID: %d\n", semId);
    for(int i = 0; i < 10; i++) {
        semaforoP(semId);
        (*p) +=5;
        printf("Valor atual: %d --- filho: %d\n", *p, getpid());
        semaforoV(semId);
        sleep(1);
    }
    shmdt (p);
    shmctl (segmento, IPC_RMID, 0);
    printf ("\nProcesso %d terminou\n", getpid());
    exit(0);
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
$gcc -Wall -o aux1 aux1.c
$gcc -Wall -o main main.c 
$./main 
-----------------------------------------------------

RESULTADO

SemID: 22
i: 0
i: 1
id do filho: 18915
id do filho: 18916
Aux1 - Entrei no filho 18915
SemID: 22
Valor atual: 1 --- filho: 18915
Aux2 - Entrei no filho 18916
SemID: 22
Valor atual: 6 --- filho: 18916
Valor atual: 7 --- filho: 18915
Valor atual: 12 --- filho: 18916
Valor atual: 13 --- filho: 18915
Valor atual: 18 --- filho: 18916
Valor atual: 19 --- filho: 18915
Valor atual: 24 --- filho: 18916
Valor atual: 29 --- filho: 18916
Valor atual: 30 --- filho: 18915
Valor atual: 35 --- filho: 18916
Valor atual: 36 --- filho: 18915
Valor atual: 41 --- filho: 18916
Valor atual: 42 --- filho: 18915
Valor atual: 47 --- filho: 18916
Valor atual: 48 --- filho: 18915
Valor atual: 53 --- filho: 18916
Valor atual: 54 --- filho: 18915
Valor atual: 59 --- filho: 18916
Valor atual: 60 --- filho: 18915

Processo 18916 terminou

Processo 18915 terminou
Processo pai 18914 terminou
-----------------------------------------------------

CONCLUSÃO 

Na main, é criado o semáforo e a memória compartilhada com chaves fixas de modo que outros 
processos podem anexar em seus programas esse sinal e memória. Depois, são criados dois filhos que 
são transformados pelo execl para seus respectivos executáveis (exec1 e exec2). Com isso, cada um 
percorre um loop com 10 iterações para fazer seu respctivo acréscimo na variável compartilhada. 
Entretanto, para que n

-----------------------------------------------------